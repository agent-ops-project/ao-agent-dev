I'm translating code from a high-level description into runnable Python code using LLMs. I take several steps to do this, and my final code is wrong. I want to figure out which was the first step that was to unclear or incorrect, such that the later steps couldn't recover from that failure. Erros could include describing a wrong design, being to inconcise, or simply not producing the right code although the previously described approach is perfectly clear. Be critical in your analysis of every step and consider each step as a possible root cause for the final error (i.e., even steps that don't produce code may be inconcise and therefore result in the wrong code). The code is part of a larger code base. The high-level task description describes functionality and what dependencies to use (e.g., dependencies inside the repo and extermal packages).

1. First, I'm doing an analysis of the high-level text. This produces a difficulty rating and description of what the LLM struggled with.
2. Second, I'm planning the implementation in several iterations. This produces high-level code that becomes more and more concrete.
3. I'm generating the actual source code. I will give you the code here and a review that the LLM gets on the generated code.

Below are all the steps and the LLM's output for the step:

---------------------------------------------
Step 1: Analyzing the high-level task description:

# Difficulty Analysis
The AgentService class is a medium complexity implementation. It has a significant number of methods (around 30) that interact with a database and manage various data models. However, the methods follow consistent patterns:
- CRUD operations for companies, contacts, tasks, etc.
- Database interactions using the provided PostgresOperations class
- Cache management for various entities
- Authentication logic

While there are many methods, they follow similar patterns and the logic within each method is relatively straightforward. The complexity comes from the number of methods and ensuring consistent behavior across them.

# Dependency Analysis
The file depends on:
1. Standard libraries: datetime, typing
2. Utility classes: HashFunc for generating IDs
3. Data models: Company, CompanyNote, Contact, ContactNote, Agent, Task, EmailTemplate
4. Database components: Schema, PostgresOperations

All these dependencies are necessary for implementing the AgentService class. The HashFunc is used for generating IDs, the data models represent the entities being managed, and the database components are used for persistence.

## Missing Dependencies
No missing dependencies identified. All necessary classes and utilities are imported.

## Irrelevant Dependencies
No irrelevant dependencies identified. All imports are used within the AgentService class.

# Implementation Approach
I would implement this file in a structured manner:

1. **Initialize the class with member variables**:
   - Set up the agent state (agent_id, agent, logged_in)
   - Initialize cache dictionaries for various entities
   - Store references to schema and database

2. **Implement authentication methods**:
   - login, forget_password, logout, show_setting

3. **Implement company-related methods**:
   - get_all_companies, show_all_company_contacts, show_all_company_tasks, get_company, add_company, remove_company, update_company

4. **Implement company note methods**:
   - get_company_notes, add_company_note, remove_company_note, update_company_note

5. **Implement contact-related methods**:
   - get_all_contacts, get_contact, add_contact, remove_contact, update_contact

6. **Implement contact note methods**:
   - get_contact_notes, add_contact_note, remove_contact_note, update_contact_note

7. **Implement task-related methods**:
   - get_all_tasks, add_task, remove_task, update_task

8. **Implement email-related methods**:
   - show_all_email_templates, send_email

9. **Implement utility methods**:
   - free (to clear caches)

For each group of methods, I would implement them in a consistent way, following the patterns established in the class. For example, all "get" methods would check the cache first, then query the database if needed. All "add" methods would create a new object, add it to the cache, and insert it into the database.

## Dedicated Implementations
No dedicated implementations needed. The AgentService class can be implemented as a single unit since the methods follow consistent patterns and are closely related.

---------------------------------------------
Step 2: Iteratively planning the implementation:

Produced plan (iteratively refined Python code):

class AgentService:
    """
    Interface for all services related to an agent.
    """

    def __init__(self, schema: Schema, database: PostgresOperations):
        """
        Initialize the agent service with schema and database connection.
        """
        self.agent_id = None
        self.agent = None
        self.logged_in = False   # In every of following methods expect self.login() and self.forget_password(), raise error if not logged_in
        # this serves as a temporary cache
        self.companies: t.Dict[int, Company] = dict()     # a dictionary company_id: Company
        self.company_notes: t.Dict[int, t.List[CompanyNote]] = dict()   # a dictionary company_id: list of CompanyNote
        self.contacts: t.Dict[int, Contact] = dict()  # a dictionary contact_id: Contact
        self.contact_notes: t.Dict[int, t.List[ContactNote]] = dict()  # a dictionary contact_id: ContactNote
        self.tasks: t.Dict[int, Task] = dict()  # a dictionary task_id: Task
        self.email_templates: t.Dict[int, EmailTemplate] = dict()   # a dictionary template_id: list of EmailTemplate
        self.schema = schema
        self.database = database

    def login(self, agent_id: int, agent_email: str, password: str) -> bool:
        """
        An agent can login using id or email, that allows him/her to perform different functionalities.
        """
        # Check if agent exists by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if not result:
            return False
        
        # Check if password matches
        agent_data = result[0]  # First row of results
        stored_password = agent_data[3]  # Assuming password is the 4th column
        
        if password != stored_password:
            return False
        
        # Create Agent object from result
        self.agent = Agent(
            agent_id=agent_data[0],
            name=agent_data[1],
            email=agent_data[2],
            password=agent_data[3]
        )
        
        self.agent_id = self.agent.agent_id
        self.logged_in = True
        
        # Load initial data
        self.get_all_tasks()
        self.get_all_contacts()
        self.get_all_companies()
        
        return True

    def forget_password(self, agent_id: int, agent_email: str) -> bool:
        """
        If agent_id or agent_email exists in the database, send an email with agent's current password to agent's email.
        """
        # Check if agent exists by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if not result:
            return False
        
        agent_data = result[0]  # First row of results
        agent_email = agent_data[2]  # Assuming email is the 3rd column
        password = agent_data[3]  # Assuming password is the 4th column
        
        # Send email with password to agent's email
        # In a real implementation, this would use an email service
        print(f"Sending password recovery email to {agent_email} with password: {password}")
        
        return True

    def logout(self):
        """
        Set self.logged_in to False and call self.free()
        """
        self.logged_in = False
        self.free()

    def show_setting(self) -> Agent:
        """
        Return self.agent
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        return self.agent

    def free(self):
        """
        Empty all local caches, self.tasks, self.companies, self.contacts, etc.
        """
        self.companies.clear()
        self.company_notes.clear()
        self.contacts.clear()
        self.contact_notes.clear()
        self.tasks.clear()
        self.email_templates.clear()

Performed steps:

# Performed Steps
In this first iteration, I've implemented:
1. All imports at the top of the file
2. The AgentService class with its constructor
3. Authentication methods (login, forget_password, logout, show_setting)
4. The free() utility method

## Full Completions
- Imports: Added all necessary imports
- AgentService.__init__: Implemented the constructor with all necessary member variables
- AgentService.login: Implemented the login method to authenticate an agent
- AgentService.forget_password: Implemented the password recovery method
- AgentService.logout: Implemented the logout method
- AgentService.show_setting: Implemented the method to return agent settings
- AgentService.free: Implemented the method to clear all caches

## Untouched Nodes
All other methods in the AgentService class remain untouched. These include:
- Company-related methods (get_all_companies, show_all_company_contacts, etc.)
- Company note methods (get_company_notes, add_company_note, etc.)
- Contact-related methods (get_all_contacts, get_contact, etc.)
- Contact note methods (get_contact_notes, add_contact_note, etc.)
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the company-related methods and company note methods.

## Next to Plan
- get_all_companies
- show_all_company_contacts
- show_all_company_tasks
- get_company
- add_company
- remove_company
- update_company
- get_company_notes
- add_company_note
- remove_company_note
- update_company_note

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns but require careful handling of database operations and cache management.


---------------------------------------------
Step 3: Iteratively planning the implementation:

Produced plan (iteratively refined Python code):

class AgentService:
    '''
    Service class for agent operations in the CRM system.
    Manages authentication, companies, contacts, tasks, and email templates.
    '''

    def __init__(self, db_operations: PostgresOperations):
        '''
        Initialize the agent service with database operations.
        
        Args:
            db_operations: Database operations interface for CRM data
        '''
        # Database operations
        self.db_operations = db_operations
        
        # Authentication state
        self.current_agent = None
        self.logged_in = False
        
        # Cache dictionaries
        self.companies_cache = {}  # company_id -> Company
        self.company_notes_cache = {}  # company_id -> list of CompanyNote
        self.contacts_cache = {}  # contact_id -> Contact
        self.contact_notes_cache = {}  # contact_id -> list of ContactNote
        self.tasks_cache = {}  # task_id -> Task
        self.email_templates_cache = {}  # template_id -> EmailTemplate

    def login(self, email: str, password: str) -> bool:
        '''
        Authenticate an agent with email and password.
        
        Args:
            email: Agent's email address
            password: Agent's password
            
        Returns:
            True if login successful, False otherwise
        '''
        # Query the database to find the agent with the given email
        query = f"SELECT * FROM agents WHERE email = '{email}' AND password = '{password}'"
        result = self.db_operations.execute_query(query)
        
        if result and len(result) > 0:
            # Create an Agent object from the result
            agent_data = result[0]
            agent_id = agent_data[0]  # Assuming first column is agent_id
            name = agent_data[1]  # Assuming second column is name
            
            # Create and store the current agent
            self.current_agent = Agent(
                agent_id=agent_id,
                name=name,
                email=email,
                password=password
            )
            self.logged_in = True
            return True
        
        return False

    def forget_password(self, email: str) -> bool:
        '''
        Process a forgotten password request for an agent.
        
        Args:
            email: Agent's email address
            
        Returns:
            True if password recovery initiated, False if agent not found
        '''
        # Query the database to check if the agent exists
        query = f"SELECT * FROM agents WHERE email = '{email}'"
        result = self.db_operations.execute_query(query)
        
        if result and len(result) > 0:
            # In a real system, this would send a password reset email
            # For this implementation, we'll just return True to indicate the agent exists
            return True
        
        return False

    def logout(self) -> bool:
        '''
        Log out the current agent.
        
        Returns:
            True if logout successful, False if no agent was logged in
        '''
        if self.logged_in:
            self.current_agent = None
            self.logged_in = False
            return True
        
        return False

    def show_setting(self) -> t.Dict[str, t.Any]:
        '''
        Return the current agent's settings.
        
        Returns:
            Dictionary containing agent settings or empty dict if not logged in
        '''
        if not self.logged_in or not self.current_agent:
            return {}
        
        return {
            'agent_id': self.current_agent.agent_id,
            'name': self.current_agent.name,
            'email': self.current_agent.email
        }

    def free(self) -> None:
        '''
        Clear all caches to free memory.
        '''
        self.companies_cache.clear()
        self.company_notes_cache.clear()
        self.contacts_cache.clear()
        self.contact_notes_cache.clear()
        self.tasks_cache.clear()
        self.email_templates_cache.clear()

Performed steps:

# Performed Steps
In this first iteration, I'll implement:
1. The AgentService class with its constructor
2. Authentication methods (login, forget_password, logout, show_setting)
3. The free() utility method

## Full Completions
- AgentService.__init__: Implemented the constructor with all necessary member variables
- AgentService.login: Implemented the login method to authenticate an agent
- AgentService.forget_password: Implemented the password recovery method
- AgentService.logout: Implemented the logout method
- AgentService.show_setting: Implemented the method to return agent settings
- AgentService.free: Implemented the method to clear all caches

## Untouched Nodes
All other methods in the AgentService class remain untouched. These include:
- Company-related methods (get_all_companies, show_all_company_contacts, etc.)
- Company note methods (get_company_notes, add_company_note, etc.)
- Contact-related methods (get_all_contacts, get_contact, etc.)
- Contact note methods (get_contact_notes, add_contact_note, etc.)
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the company-related methods and company note methods.

## Next to Plan
- get_all_companies
- show_all_company_contacts
- show_all_company_tasks
- get_company
- add_company
- remove_company
- update_company
- get_company_notes
- add_company_note
- remove_company_note
- update_company_note

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns but require careful handling of database operations and cache management.


---------------------------------------------
Step 4: Implementing the actual code (implementation and review):

Implemmentation:

from datetime import datetime
import typing as t
from .utils import HashFunc
from .data_models import Company, CompanyNote, Contact, ContactNote, Agent, Task, EmailTemplate
from database.schema import Schema
from database.db_operations import PostgresOperations


class AgentService:
    """
    Interface for all services related to an agent.
    """

    def __init__(self, schema: Schema, database: PostgresOperations):
        """
        Include more attributes that can be helpful
        """
        self.agent_id = None
        self.agent = None
        self.logged_in = False   # In every of following methods expect self.login() and self.forget_password(), raise error if not logged_in
        # this serves as a temporary cache
        self.companies: t.Dict[int, Company] = dict()     # a dictionary company_id: Company
        self.company_notes: t.Dict[int, t.List[CompanyNote]] = dict()   # a dictionary company_id: list of CompanyNote
        self.contacts: t.Dict[int, Contact] = dict()  # a dictionary contact_id: Contact
        self.contact_notes: t.Dict[int, t.List[ContactNote]] = dict()  # a dictionary contact_id: ContactNote
        self.tasks: t.Dict[int, Task] = dict()  # a dictionary task_id: Task
        self.email_templates: t.Dict[int, EmailTemplate] = dict()   # a dictionary template_id: list of EmailTemplate
        self.schema = schema
        self.database = database

    def login(self, agent_id: int, agent_email: str, password: str) -> bool:
        """
        An agent can login using id or email, that allows him/her to perform different functionalities.
        Check if agent_id or agent_email exists in the database.
        If so, you need to match the input password with the stored password.
        If matched, update self.agent_id, self.agent, self.logged_in and call get_all_tasks(), get_all_contacts() and get_all_companies().
        If successful, return True.
        """
        # Query to find agent by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            agent_data = result[0]
            stored_password = agent_data[3]  # Assuming password is the 4th column
            
            if stored_password == password:
                # Set agent information
                self.agent_id = agent_data[0]  # Assuming agent_id is the 1st column
                self.agent = Agent(
                    agent_id=agent_data[0],
                    name=agent_data[1],
                    email=agent_data[2],
                    password=agent_data[3]
                )
                self.logged_in = True
                
                # Load data
                self.get_all_tasks()
                self.get_all_contacts()
                self.get_all_companies(order_by_target_funding=False)
                
                return True
        
        return False

    def forget_password(self, agent_id: int, agent_email: str) -> bool:
        """
        If agent_id or agent_email exists in the database, send an email with agent's current password to agent's email
        If successful, return True.
        """
        # Query to find agent by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            agent_data = result[0]
            agent_email = agent_data[2]  # Assuming email is the 3rd column
            password = agent_data[3]     # Assuming password is the 4th column
            
            # In a real system, this would send an email with the password
            # For this implementation, we'll just return True to indicate the agent exists
            return True
        
        return False

    def logout(self):
        """
        set self.logged_in to False and call self.free()
        """
        if not self.logged_in:
            return
        
        self.logged_in = False
        self.agent_id = None
        self.agent = None
        self.free()

    def show_setting(self) -> Agent:
        """
        Return self.agent
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        return self.agent

    def get_all_companies(self, order_by_target_funding: bool):
        """
        Return all companies assigned to the current agent.
        Write and execute a SQL query in postgres syntax to retrieve all companies (with all columns) with
              companies.company_id = contacts.company_id and contacts.assigned_agent_id = self.agent_id
        If order_by_target_funding is true, sort by 'target_funding' column in descending order
        Store the retrieved companies in self.companies
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"""
            SELECT DISTINCT c.* FROM companies c
            JOIN contacts ct ON c.company_id = ct.company_id
            WHERE ct.assigned_agent_id = {self.agent_id}
        """
        
        if order_by_target_funding:
            query += " ORDER BY c.target_funding DESC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        # Clear existing companies cache
        self.companies.clear()
        
        if results:
            for company_data in results:
                company_id = company_data[0]  # Assuming company_id is the 1st column
                name = company_data[1]        # Assuming name is the 2nd column
                main_contact_id = company_data[2]  # Assuming main_contact_id is the 3rd column
                target_funding = company_data[3]   # Assuming target_funding is the 4th column
                grant_type = company_data[4]       # Assuming grant_type is the 5th column
                status = company_data[5]           # Assuming status is the 6th column
                renewal_date = company_data[6]     # Assuming renewal_date is the 7th column
                
                company = Company(
                    company_id=company_id,
                    name=name,
                    main_contact_id=main_contact_id,
                    target_funding=target_funding,
                    grant_type=grant_type,
                    status=status,
                    renewal_date=renewal_date
                )
                
                self.companies[company_id] = company

    def show_all_company_contacts(self, company_id: int) -> t.List[Contact]:
        """
        Loop through self.contacts and find all contacts associated with this company.
        Return a list of contacts
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        company_contacts = []
        
        for contact in self.contacts.values():
            if contact.company_id == company_id:
                company_contacts.append(contact)
        
        return company_contacts

    def show_all_company_tasks(self, company_id: int, order_by_due_date: bool = True) -> t.List[Task]:
        """
        Loop through self.tasks and find all tasks associated with this company.
        If order_by_due_date is true, sort by task's 'due_date' in descending order
        Return a list of tasks
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        company_tasks = []
        
        for task in self.tasks.values():
            if task.company_id == company_id:
                company_tasks.append(task)
        
        if order_by_due_date:
            company_tasks.sort(key=lambda task: task.due_time if task.due_time else "", reverse=True)
        
        return company_tasks

    def get_company(self, company_id: int) -> Company:
        """
        Return the company with id 'company_id'.
        First check in self.companies.
        If not found, search in self.database. If not found in database, raise error.
        Add the company to self.companies and return it.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if company is in cache
        if company_id in self.companies:
            return self.companies[company_id]
        
        # Query the database for this company
        query = f"SELECT * FROM companies WHERE company_id = {company_id}"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            company_data = result[0]
            name = company_data[1]        # Assuming name is the 2nd column
            main_contact_id = company_data[2]  # Assuming main_contact_id is the 3rd column
            target_funding = company_data[3]   # Assuming target_funding is the 4th column
            grant_type = company_data[4]       # Assuming grant_type is the 5th column
            status = company_data[5]           # Assuming status is the 6th column
            renewal_date = company_data[6]     # Assuming renewal_date is the 7th column
            
            company = Company(
                company_id=company_id,
                name=name,
                main_contact_id=main_contact_id,
                target_funding=target_funding,
                grant_type=grant_type,
                status=status,
                renewal_date=renewal_date
            )
            
            # Add to cache
            self.companies[company_id] = company
            return company
        
        raise ValueError(f"Company with ID {company_id} not found")

    def add_company(self,
                    name: str,
                    main_contact_id: int,
                    target_funding: float,
                    grant_type: str = "",
                    status: str = "New",
                    renewal_date: str = "",
                    company_id: int = None,
                    ) -> Company:
        """
        If company_id is None or -1, we will create a new company_id using HashFunc.hash_company_id()
        Create a new Company object.
        Add it to self.companies and insert it into the database using insert_record() function
        Return the newly created Company, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate company ID if not provided
        if company_id is None or company_id == -1:
            company_id = HashFunc.hash_company_id(name, main_contact_id, target_funding)
        
        # Create new Company object
        company = Company(
            company_id=company_id,
            name=name,
            main_contact_id=main_contact_id,
            target_funding=target_funding,
            grant_type=grant_type,
            status=status,
            renewal_date=renewal_date
        )
        
        # Insert into database
        success = self.database.insert_record(Company.db_table_names(), company.to_record())
        
        if not success:
            raise ValueError("Failed to add company to database")
        
        # Add to cache
        self.companies[company_id] = company
        
        return company

    def remove_company(self, company_id: int) -> bool:
        """
        Remove a company from self.companies (if exists).
        Remove it from self.database using delete_record() function
        Return True if successfully removed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(Company.db_table_names(), company_id)
        
        if success:
            # Remove from cache if present
            if company_id in self.companies:
                del self.companies[company_id]
            
            # Also remove associated company notes from cache
            if company_id in self.company_notes:
                del self.company_notes[company_id]
            
            return True
        
        return False

    def update_company(self, company_id: int, **kwargs) -> Company:
        """
        First get_company() and then update its corresponding attribute values based on **kwargs.
        You also need to update this company in self.database using update_record() function
        Return the updated Company, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Get the company
        company = self.get_company(company_id)
        
        # Update company attributes
        company.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Company.db_table_names(), company.to_record())
        
        if not success:
            raise ValueError(f"Failed to update company with ID {company_id}")
        
        # Update in cache
        self.companies[company_id] = company
        
        return company

    def get_company_notes(self, company_id: int, order_by_create_date: bool=True) -> t.List[CompanyNote]:
        """
        Return a list of company notes.
        Write and execute a SQL query in postgres syntax to retrieve all company notes (with all columns)
            with company_notes.company_id = company_id.
        If order_by_create_date is true, sort by 'create_time' column in descending order
        Add the retrieved company notes to self.company_notes and return them.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"SELECT * FROM company_notes WHERE company_id = {company_id}"
        
        if order_by_create_date:
            query += " ORDER BY create_time DESC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        notes = []
        if results:
            for note_data in results:
                note_id = note_data[0]       # Assuming note_id is the 1st column
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time = note_data[2]   # Assuming create_time is the 3rd column
                
                # Create CompanyNote object
                company_note = CompanyNote(
                    company_note_id=note_id,
                    company_id=company_id,
                    note=note_text,
                    create_time=create_time
                )
                notes.append(company_note)
        
        # Add to cache
        self.company_notes[company_id] = notes
        
        return notes

    def add_company_note(self,
                         company_id: int,
                         new_note: str,
                         create_time: str = '',
                         company_note_id: int = None) -> CompanyNote:
        """
        If company_note_id is None or -1, we will create a new company_note_id using HashFunc.hash_company_note_id()
        Create a new CompanyNote object.
        Add it to self.company_notes and insert it into the database using insert_record() function
        Return the newly created CompanyNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate note ID if not provided
        if company_note_id is None or company_note_id == -1:
            company_note_id = HashFunc.hash_company_note_id(company_id, new_note)
        
        # Set create time if not provided
        if not create_time:
            create_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Create new CompanyNote object
        company_note = CompanyNote(
            company_note_id=company_note_id,
            company_id=company_id,
            note=new_note,
            create_time=create_time
        )
        
        # Insert into database
        success = self.database.insert_record(CompanyNote.db_table_names(), company_note.to_record())
        
        if not success:
            raise ValueError("Failed to add company note to database")
        
        # Add to cache
        if company_id not in self.company_notes:
            self.company_notes[company_id] = []
        self.company_notes[company_id].append(company_note)
        
        return company_note

    def remove_company_note(self, company_id: int, company_note_id: int) -> bool:
        """
        Remove a company note with company_id and company_note_id.
        If it exists in self.company_notes, remove it.
        Remove company note from self.database using delete_record() function
        Return True if successfully removed.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(CompanyNote.db_table_names(), company_note_id)
        
        if success:
            # Remove from cache if present
            if company_id in self.company_notes:
                self.company_notes[company_id] = [
                    note for note in self.company_notes[company_id] 
                    if note.company_note_id != company_note_id
                ]
            
            return True
        
        return False

    def update_company_note(self, company_id: int, company_note_id: int, new_note: str) -> CompanyNote:
        """
        First get the CompanyNote object with company_id, company_note_id from self.company_notes or self.database.
        Then update its note with new_note.
        You also need to update this company note in self.database using update_record() function
        Return the updated CompanyNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Find the note in cache
        company_note = None
        if company_id in self.company_notes:
            for note in self.company_notes[company_id]:
                if note.company_note_id == company_note_id:
                    company_note = note
                    break
        
        # If not in cache, query from database
        if not company_note:
            query = f"SELECT * FROM company_notes WHERE company_note_id = {company_note_id}"
            result = self.database.execute_query(query)
            
            if result and len(result) > 0:
                note_data = result[0]
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time = note_data[2]   # Assuming create_time is the 3rd column
                
                company_note = CompanyNote(
                    company_note_id=company_note_id,
                    company_id=company_id,
                    note=note_text,
                    create_time=create_time
                )
        
        if not company_note:
            raise ValueError(f"Company note with ID {company_note_id} not found")
        
        # Update note text
        company_note.update_attribute(note=new_note)
        
        # Update in database
        success = self.database.update_record(CompanyNote.db_table_names(), company_note.to_record())
        
        if not success:
            raise ValueError(f"Failed to update company note with ID {company_note_id}")
        
        # Update in cache
        if company_id in self.company_notes:
            for i, note in enumerate(self.company_notes[company_id]):
                if note.company_note_id == company_note_id:
                    self.company_notes[company_id][i] = company_note
                    break
        
        return company_note

    def get_all_contacts(self, sort_by_companies: bool = True):
        """
        Return all contacts assigned to the current agent.
        Write and execute a SQL query in postgres syntax to retrieve all contacts (with all columns) with contacts.assigned_agent_id = self.agent_id
        If group_by_companies is true, sort by 'company_id' column
        Returns:
            Store the retrieved contacts in dictionary self.contacts
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"SELECT * FROM contacts WHERE assigned_agent_id = {self.agent_id}"
        
        if sort_by_companies:
            query += " ORDER BY company_id"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        # Clear existing contacts cache
        self.contacts.clear()
        
        if results:
            for contact_data in results:
                contact_id = contact_data[0]      # Assuming contact_id is the 1st column
                name = contact_data[1]            # Assuming name is the 2nd column
                email = contact_data[2]           # Assuming email is the 3rd column
                company_id = contact_data[3]      # Assuming company_id is the 4th column
                assigned_agent_id = contact_data[4]  # Assuming assigned_agent_id is the 5th column
                status = contact_data[5]          # Assuming status is the 6th column
                
                contact = Contact(
                    contact_id=contact_id,
                    name=name,
                    email=email,
                    company_id=company_id,
                    assigned_agent_id=assigned_agent_id,
                    status=status
                )
                
                self.contacts[contact_id] = contact

    def get_contact(self, contact_id: int) -> Contact:
        """
        Return the contact with id 'contact_id'.
        First check in self.contacts.
        If not found, search in self.database. If not found in database, raise error.
        Add the contact to self.contacts and return it.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if contact is in cache
        if contact_id in self.contacts:
            return self.contacts[contact_id]
        
        # Query the database for this contact
        query = f"SELECT * FROM contacts WHERE contact_id = {contact_id}"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            contact_data = result[0]
            name = contact_data[1]            # Assuming name is the 2nd column
            email = contact_data[2]           # Assuming email is the 3rd column
            company_id = contact_data[3]      # Assuming company_id is the 4th column
            assigned_agent_id = contact_data[4]  # Assuming assigned_agent_id is the 5th column
            status = contact_data[5]          # Assuming status is the 6th column
            
            contact = Contact(
                contact_id=contact_id,
                name=name,
                email=email,
                company_id=company_id,
                assigned_agent_id=assigned_agent_id,
                status=status
            )
            
            # Add to cache
            self.contacts[contact_id] = contact
            return contact
        
        raise ValueError(f"Contact with ID {contact_id} not found")

    def add_contact(self,
                    name: str,
                    email: str,
                    company_id: int,
                    assigned_agent_id: int = -1,
                    status: str = 'new',
                    contact_id: int = None) -> Contact:
        """
        If contact_id is None or -1, we will create a new contact_id using HashFunc.hash_contact_id()
        Create a new Contact object.
        Add it to self.contacts and insert it into the database using insert_record() function
        Return the newly created Contact, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Use current agent ID if not specified
        if assigned_agent_id == -1:
            assigned_agent_id = self.agent_id
        
        # Generate contact ID if not provided
        if contact_id is None or contact_id == -1:
            contact_id = HashFunc.hash_contact_id(name, email, company_id)
        
        # Create new Contact object
        contact = Contact(
            contact_id=contact_id,
            name=name,
            email=email,
            company_id=company_id,
            assigned_agent_id=assigned_agent_id,
            status=status
        )
        
        # Insert into database
        success = self.database.insert_record(Contact.db_table_names(), contact.to_record())
        
        if not success:
            raise ValueError("Failed to add contact to database")
        
        # Add to cache
        self.contacts[contact_id] = contact
        
        return contact

    def remove_contact(self, contact_id: int) -> bool:
        """
        Remove the contact from self.contact (if exists).
        Remove it from self.database using delete_record() function
        Return True if successfully removed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(Contact.db_table_names(), contact_id)
        
        if success:
            # Remove from cache if present
            if contact_id in self.contacts:
                del self.contacts[contact_id]
            
            # Also remove associated contact notes from cache
            if contact_id in self.contact_notes:
                del self.contact_notes[contact_id]
            
            return True
        
        return False

    def update_contact(self, contact_id: int, **kwargs) -> Contact:
        """
        First get_contact() and then update its corresponding attribute values based on **kwargs.
        You also need to update this contact in self.database using update_record() function
        Return the updated Contact, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Get the contact
        contact = self.get_contact(contact_id)
        
        # Update contact attributes
        contact.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Contact.db_table_names(), contact.to_record())
        
        if not success:
            raise ValueError(f"Failed to update contact with ID {contact_id}")
        
        # Update in cache
        self.contacts[contact_id] = contact
        
        return contact

    def get_contact_notes(self, contact_id: int, order_by_create_date: bool = True) -> t.List[ContactNote]:
        """
        Return a list of contact notes.
        Write and execute a SQL query in postgres syntax to retrieve all contact notes (with all columns)
            with contact_notes.contact_id = contact_id.
        If order_by_create_date is true, sort by 'create_time' column in descending order
        Add the retrieve contact notes to self.contact_notes and return them.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"SELECT * FROM contact_notes WHERE contact_id = {contact_id}"
        
        if order_by_create_date:
            query += " ORDER BY create_time DESC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        notes = []
        if results:
            for note_data in results:
                note_id = note_data[0]       # Assuming note_id is the 1st column
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time = note_data[2]   # Assuming create_time is the 3rd column
                assigned_agent_id = note_data[4]  # Assuming assigned_agent_id is the 5th column
                
                # Create ContactNote object
                contact_note = ContactNote(
                    contact_note_id=note_id,
                    contact_id=contact_id,
                    note=note_text,
                    create_time=create_time,
                    assigned_agent_id=assigned_agent_id
                )
                notes.append(contact_note)
        
        # Add to cache
        self.contact_notes[contact_id] = notes
        
        return notes

    def add_contact_note(self,
                         contact_id: int,
                         new_note: str,
                         assigned_agent_id: int,
                         create_time: str = '',
                         contact_note_id: int = None) -> ContactNote:
        """
        If contact_note_id is None or -1, we will create a new contact_note_id using HashFunc.hash_contact_note_id()
        Create a new ContactNote object.
        Add it to self.contact_notes and insert it into the database using insert_record() function
        Return the newly created ContactNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate note ID if not provided
        if contact_note_id is None or contact_note_id == -1:
            contact_note_id = HashFunc.hash_contact_note_id(contact_id, new_note)
        
        # Set create time if not provided
        if not create_time:
            create_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Create new ContactNote object
        contact_note = ContactNote(
            contact_note_id=contact_note_id,
            contact_id=contact_id,
            note=new_note,
            create_time=create_time,
            assigned_agent_id=assigned_agent_id
        )
        
        # Insert into database
        success = self.database.insert_record(ContactNote.db_table_names(), contact_note.to_record())
        
        if not success:
            raise ValueError("Failed to add contact note to database")
        
        # Add to cache
        if contact_id not in self.contact_notes:
            self.contact_notes[contact_id] = []
        self.contact_notes[contact_id].append(contact_note)
        
        return contact_note

    def remove_contact_note(self, contact_id: int, contact_note_id: int) -> bool:
        """
        Remove a contact note with contact_id and contact_note_id.
        If it exists in self.contact_notes, remove it.
        Remove company note from self.database using delete_record() function
        Return True if successfully removed.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(ContactNote.db_table_names(), contact_note_id)
        
        if success:
            # Remove from cache if present
            if contact_id in self.contact_notes:
                self.contact_notes[contact_id] = [
                    note for note in self.contact_notes[contact_id] 
                    if note.contact_note_id != contact_note_id
                ]
            
            return True
        
        return False

    def update_contact_note(self, contact_id: int, contact_note_id: int, **kwargs) -> ContactNote:
        """
        First get the ContactNote object with contact_id, contact_note_id from self.contact_notes or self.database.
        Then update it with **kwargs
        You also need to update this contact note in self.database using update_record() function
        Return the updated ContactNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Find the note in cache
        contact_note = None
        if contact_id in self.contact_notes:
            for note in self.contact_notes[contact_id]:
                if note.contact_note_id == contact_note_id:
                    contact_note = note
                    break
        
        # If not in cache, query from database
        if not contact_note:
            query = f"SELECT * FROM contact_notes WHERE contact_note_id = {contact_note_id}"
            result = self.database.execute_query(query)
            
            if result and len(result) > 0:
                note_data = result[0]
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time = note_data[2]   # Assuming create_time is the 3rd column
                assigned_agent_id = note_data[4]  # Assuming assigned_agent_id is the 5th column
                
                contact_note = ContactNote(
                    contact_note_id=contact_note_id,
                    contact_id=contact_id,
                    note=note_text,
                    create_time=create_time,
                    assigned_agent_id=assigned_agent_id
                )
        
        if not contact_note:
            raise ValueError(f"Contact note with ID {contact_note_id} not found")
        
        # Update note attributes
        contact_note.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(ContactNote.db_table_names(), contact_note.to_record())
        
        if not success:
            raise ValueError(f"Failed to update contact note with ID {contact_note_id}")
        
        # Update in cache
        if contact_id in self.contact_notes:
            for i, note in enumerate(self.contact_notes[contact_id]):
                if note.contact_note_id == contact_note_id:
                    self.contact_notes[contact_id][i] = contact_note
                    break
        
        return contact_note

    def get_all_tasks(self, order_by_due_date: bool = True):
        """
        Return all tasks assigned to the current agent.
        Write and execute a SQL query in postgres syntax to retrieve all tasks (with all columns) with tasks.assigned_to = self.agent_id
        If order_by_due_date is true, add a sort statement on 'due_time' column to the SQL (in ascending order)
        Store the retrieved tasks in dictionary self.tasks
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"SELECT * FROM tasks WHERE assigned_agent_id = {self.agent_id}"
        
        if order_by_due_date:
            query += " ORDER BY due_time ASC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        # Clear existing tasks cache
        self.tasks.clear()
        
        if results:
            for task_data in results:
                task_id = task_data[0]           # Assuming task_id is the 1st column
                name = task_data[1]              # Assuming name is the 2nd column
                assigned_agent_id = task_data[2]  # Assuming assigned_agent_id is the 3rd column
                contact_id = task_data[3]        # Assuming contact_id is the 4th column
                company_id = task_data[4]        # Assuming company_id is the 5th column
                description = task_data[5]       # Assuming description is the 6th column
                create_time = task_data[6]       # Assuming create_time is the 7th column
                due_time = task_data[7]          # Assuming due_time is the 8th column
                status = task_data[8]            # Assuming status is the 9th column
                
                task = Task(
                    task_id=task_id,
                    name=name,
                    assigned_agent_id=assigned_agent_id,
                    contact_id=contact_id,
                    company_id=company_id,
                    description=description,
                    create_time=create_time,
                    due_time=due_time,
                    status=status
                )
                
                self.tasks[task_id] = task

    def add_task(self,
                 assigned_agent_id: int,
                 contact_id: int,
                 company_id: int,
                 name: str,
                 description: str,
                 create_time: str = '',
                 due_time: str = '',
                 status: str = 'incomplete',
                 task_id: int = None) -> Task:
        """
        If task_id is None or -1, we will create a new task_id using HashFunc.hash_task_id()
        Create a new Task object.
        Add it to self.tasks (preserving the descending order by due_time) and insert it into the database using insert_record() function
        Return the newly created Task, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate task ID if not provided
        if task_id is None or task_id == -1:
            task_id = HashFunc.hash_task_id(assigned_agent_id, contact_id, company_id, name)
        
        # Set create time if not provided
        if not create_time:
            create_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Create new Task object
        task = Task(
            task_id=task_id,
            name=name,
            assigned_agent_id=assigned_agent_id,
            contact_id=contact_id,
            company_id=company_id,
            description=description,
            create_time=create_time,
            due_time=due_time,
            status=status
        )
        
        # Insert into database
        success = self.database.insert_record(Task.db_table_names(), task.to_record())
        
        if not success:
            raise ValueError("Failed to add task to database")
        
        # Add to cache
        self.tasks[task_id] = task
        
        return task

    def remove_task(self, task_id: int) -> bool:
        """
        Remove the contact from self.tasks (if exists).
        Remove it from self.database using delete_record() function
        Return True if successfully removed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(Task.db_table_names(), task_id)
        
        if success:
            # Remove from cache if present
            if task_id in self.tasks:
                del self.tasks[task_id]
            
            return True
        
        return False

    def update_task(self, task_id: int, **kwargs) -> Task:
        """
        First get_task() and then update its corresponding attribute values based on **kwargs.
        You also need to update this task in self.database using update_record() function
        Return the updated Task, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if task exists in cache
        if task_id in self.tasks:
            task = self.tasks[task_id]
        else:
            # Query the database for this task
            query = f"SELECT * FROM tasks WHERE task_id = {task_id}"
            result = self.database.execute_query(query)
            
            if not result or len(result) == 0:
                raise ValueError(f"Task with ID {task_id} not found")
                
            task_data = result[0]
            name = task_data[1]              # Assuming name is the 2nd column
            assigned_agent_id = task_data[2]  # Assuming assigned_agent_id is the 3rd column
            contact_id = task_data[3]        # Assuming contact_id is the 4th column
            company_id = task_data[4]        # Assuming company_id is the 5th column
            description = task_data[5]       # Assuming description is the 6th column
            create_time = task_data[6]       # Assuming create_time is the 7th column
            due_time = task_data[7]          # Assuming due_time is the 8th column
            status = task_data[8]            # Assuming status is the 9th column
            
            task = Task(
                task_id=task_id,
                name=name,
                assigned_agent_id=assigned_agent_id,
                contact_id=contact_id,
                company_id=company_id,
                description=description,
                create_time=create_time,
                due_time=due_time,
                status=status
            )
            self.tasks[task_id] = task
        
        # Update task attributes
        task.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Task.db_table_names(), task.to_record())
        
        if not success:
            raise ValueError(f"Failed to update task with ID {task_id}")
        
        # Update in cache
        self.tasks[task_id] = task
        
        return task

    def show_all_email_templates(self) -> t.List[EmailTemplate]:
        """
        Retrieve all email templates.
        If self.email_templates is None, you need to write and execute a SQL query in postgres syntax to retrieve all email templates and add them to self.email_templates
        Return list of all EmailTemplate
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if we need to fetch from database
        if not self.email_templates:
            # Query all email templates from the database
            query = "SELECT * FROM email_templates"
            results = self.database.execute_query(query)
            
            if results:
                for template_data in results:
                    template_id = template_data[0]       # Assuming template_id is the 1st column
                    email_subject = template_data[1]     # Assuming email_subject is the 2nd column
                    email_text = template_data[2]        # Assuming email_text is the 3rd column
                    
                    template = EmailTemplate(
                        email_template_id=template_id,
                        email_subject=email_subject,
                        email_text=email_text
                    )
                    self.email_templates[template_id] = template
        
        # Return all email templates from cache
        return list(self.email_templates.values())

    def send_email(self, contact_id: int, email_subject: str, email_content: str) -> bool:
        """
        Add a new contact note using add_contact_note()
              kwargs = {"contact_id": contact_id,
                        "assigned_agent_id": self.agent_id,
                        "subject": "Sending email with subject: " + email_subject,
                        "note" = email_content
                        }
        Get the email address of the current agent and the email of contact with id 'contact_id'.
        Send an email from agent to contact
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Get the contact to find their email
        contact = self.get_contact(contact_id)
        if not contact:
            return False
        
        # Add a note about the email
        note_text = f"Sending email with subject: {email_subject}

{email_content}"
        self.add_contact_note(
            contact_id=contact_id,
            new_note=note_text,
            assigned_agent_id=self.agent_id
        )
        
        # In a real system, this would send an actual email
        # For this implementation, we'll just return True to indicate success
        # Simulate sending email from self.agent.email to contact.email
        
        return True

    def free(self):
        """
        Empty all local caches, self.tasks, self.companies, self.contacts, etc.
        """
        self.companies.clear()
        self.company_notes.clear()
        self.contacts.clear()
        self.contact_notes.clear()
        self.tasks.clear()
        self.email_templates.clear()

Review:

# Transpilation Review
The transpilation is not correct. There are several type errors that need to be fixed.

## Compilation Review
### Failures
1. Type mismatch in `login()` method: `self.agent` is initialized as `None` but assigned an `Agent` object.
2. Return type mismatch in `show_setting()`: Returns `None` but expected to return `Agent`.
3. Type mismatch in `add_company()`: 
   - `company_id` parameter has default value `None` but is typed as `int`
   - `target_funding` is passed as `float` to `hash_company_id()` which expects `int`
   - `renewal_date` is passed as `str` to `Company` constructor which expects `datetime | None`
4. Similar type issues in `add_company_note()`, `add_contact()`, `add_contact_note()`, and `add_task()` methods.
5. Incorrect parameter name in `EmailTemplate` constructor: using `email_template_id` instead of `template_id`.
6. Incorrect handling of datetime fields in various model constructors.
7. Missing or incorrect parameters in `Task` constructor.

### Fixes
1. Update type annotations to use `Optional[int]` or `int | None` for parameters that can be None.
2. Convert string dates to datetime objects before passing to model constructors.
3. Convert float to int for `target_funding` when passing to `hash_company_id()`.
4. Fix parameter names in `EmailTemplate` constructor.
5. Fix `Task` constructor parameters to match the expected signature.
6. Ensure `self.agent` is properly initialized in `__init__()` method.
7. Fix `show_setting()` to properly return the agent object.


---------------------------------------------
Step 5: Implementing the actual code (implementation and review):

Implemmentation:

from datetime import datetime
import typing as t
from typing import Optional
from .utils import HashFunc
from .data_models import Company, CompanyNote, Contact, ContactNote, Agent, Task, EmailTemplate
from database.schema import Schema
from database.db_operations import PostgresOperations


class AgentService:
    """
    Interface for all services related to an agent.
    """

    def __init__(self, schema: Schema, database: PostgresOperations):
        """
        Include more attributes that can be helpful
        """
        self.agent_id: Optional[int] = None
        self.agent: Optional[Agent] = None
        self.logged_in = False   # In every of following methods expect self.login() and self.forget_password(), raise error if not logged_in
        # this serves as a temporary cache
        self.companies: t.Dict[int, Company] = dict()     # a dictionary company_id: Company
        self.company_notes: t.Dict[int, t.List[CompanyNote]] = dict()   # a dictionary company_id: list of CompanyNote
        self.contacts: t.Dict[int, Contact] = dict()  # a dictionary contact_id: Contact
        self.contact_notes: t.Dict[int, t.List[ContactNote]] = dict()  # a dictionary contact_id: ContactNote
        self.tasks: t.Dict[int, Task] = dict()  # a dictionary task_id: Task
        self.email_templates: t.Dict[int, EmailTemplate] = dict()   # a dictionary template_id: list of EmailTemplate
        self.schema = schema
        self.database = database

    def login(self, agent_id: int, agent_email: str, password: str) -> bool:
        """
        An agent can login using id or email, that allows him/her to perform different functionalities.
        Check if agent_id or agent_email exists in the database.
        If so, you need to match the input password with the stored password.
        If matched, update self.agent_id, self.agent, self.logged_in and call get_all_tasks(), get_all_contacts() and get_all_companies().
        If successful, return True.
        """
        # Query to find agent by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            agent_data = result[0]
            stored_password = agent_data[3]  # Assuming password is the 4th column
            
            if stored_password == password:
                # Set agent information
                self.agent_id = agent_data[0]  # Assuming agent_id is the 1st column
                self.agent = Agent(
                    agent_id=agent_data[0],
                    name=agent_data[1],
                    email=agent_data[2],
                    password=agent_data[3]
                )
                self.logged_in = True
                
                # Load data
                self.get_all_tasks()
                self.get_all_contacts()
                self.get_all_companies(order_by_target_funding=False)
                
                return True
        
        return False

    def forget_password(self, agent_id: int, agent_email: str) -> bool:
        """
        If agent_id or agent_email exists in the database, send an email with agent's current password to agent's email
        If successful, return True.
        """
        # Query to find agent by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            agent_data = result[0]
            agent_email = agent_data[2]  # Assuming email is the 3rd column
            password = agent_data[3]     # Assuming password is the 4th column
            
            # In a real system, this would send an email with the password
            # For this implementation, we'll just return True to indicate the agent exists
            return True
        
        return False

    def logout(self):
        """
        set self.logged_in to False and call self.free()
        """
        if not self.logged_in:
            return
        
        self.logged_in = False
        self.agent_id = None
        self.agent = None
        self.free()

    def show_setting(self) -> Agent:
        """
        Return self.agent
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        if self.agent is None:
            raise ValueError("Agent information not available")
            
        return self.agent

    def get_all_companies(self, order_by_target_funding: bool):
        """
        Return all companies assigned to the current agent.
        Write and execute a SQL query in postgres syntax to retrieve all companies (with all columns) with
              companies.company_id = contacts.company_id and contacts.assigned_agent_id = self.agent_id
        If order_by_target_funding is true, sort by 'target_funding' column in descending order
        Store the retrieved companies in self.companies
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"""
            SELECT DISTINCT c.* FROM companies c
            JOIN contacts ct ON c.company_id = ct.company_id
            WHERE ct.assigned_agent_id = {self.agent_id}
        """
        
        if order_by_target_funding:
            query += " ORDER BY c.target_funding DESC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        # Clear existing companies cache
        self.companies.clear()
        
        if results:
            for company_data in results:
                company_id = company_data[0]  # Assuming company_id is the 1st column
                name = company_data[1]        # Assuming name is the 2nd column
                main_contact_id = company_data[2]  # Assuming main_contact_id is the 3rd column
                target_funding = company_data[3]   # Assuming target_funding is the 4th column
                grant_type = company_data[4]       # Assuming grant_type is the 5th column
                status = company_data[5]           # Assuming status is the 6th column
                renewal_date_str = company_data[6]  # Assuming renewal_date is the 7th column
                
                # Convert string date to datetime if not None
                renewal_date = None
                if renewal_date_str:
                    renewal_date = datetime.strptime(renewal_date_str, "%Y-%m-%d %H:%M:%S")
                
                company = Company(
                    company_id=company_id,
                    name=name,
                    main_contact_id=main_contact_id,
                    target_funding=target_funding,
                    grant_type=grant_type,
                    status=status,
                    renewal_date=renewal_date
                )
                
                self.companies[company_id] = company

    def show_all_company_contacts(self, company_id: int) -> t.List[Contact]:
        """
        Loop through self.contacts and find all contacts associated with this company.
        Return a list of contacts
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        company_contacts = []
        
        for contact in self.contacts.values():
            if contact.company_id == company_id:
                company_contacts.append(contact)
        
        return company_contacts

    def show_all_company_tasks(self, company_id: int, order_by_due_date: bool = True) -> t.List[Task]:
        """
        Loop through self.tasks and find all tasks associated with this company.
        If order_by_due_date is true, sort by task's 'due_date' in descending order
        Return a list of tasks
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        company_tasks = []
        
        for task in self.tasks.values():
            if task.company_id == company_id:
                company_tasks.append(task)
        
        if order_by_due_date:
            company_tasks.sort(key=lambda task: task.due_time if task.due_time else datetime.min, reverse=True)
        
        return company_tasks

    def get_company(self, company_id: int) -> Company:
        """
        Return the company with id 'company_id'.
        First check in self.companies.
        If not found, search in self.database. If not found in database, raise error.
        Add the company to self.companies and return it.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if company is in cache
        if company_id in self.companies:
            return self.companies[company_id]
        
        # Query the database for this company
        query = f"SELECT * FROM companies WHERE company_id = {company_id}"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            company_data = result[0]
            name = company_data[1]        # Assuming name is the 2nd column
            main_contact_id = company_data[2]  # Assuming main_contact_id is the 3rd column
            target_funding = company_data[3]   # Assuming target_funding is the 4th column
            grant_type = company_data[4]       # Assuming grant_type is the 5th column
            status = company_data[5]           # Assuming status is the 6th column
            renewal_date_str = company_data[6]  # Assuming renewal_date is the 7th column
            
            # Convert string date to datetime if not None
            renewal_date = None
            if renewal_date_str:
                renewal_date = datetime.strptime(renewal_date_str, "%Y-%m-%d %H:%M:%S")
            
            company = Company(
                company_id=company_id,
                name=name,
                main_contact_id=main_contact_id,
                target_funding=target_funding,
                grant_type=grant_type,
                status=status,
                renewal_date=renewal_date
            )
            
            # Add to cache
            self.companies[company_id] = company
            return company
        
        raise ValueError(f"Company with ID {company_id} not found")

    def add_company(self,
                    name: str,
                    main_contact_id: int,
                    target_funding: float,
                    grant_type: str = "",
                    status: str = "New",
                    renewal_date: str = "",
                    company_id: Optional[int] = None,
                    ) -> Company:
        """
        If company_id is None or -1, we will create a new company_id using HashFunc.hash_company_id()
        Create a new Company object.
        Add it to self.companies and insert it into the database using insert_record() function
        Return the newly created Company, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate company ID if not provided
        if company_id is None or company_id == -1:
            company_id = HashFunc.hash_company_id(name, main_contact_id, int(target_funding))
        
        # Convert string date to datetime if not None
        renewal_date_obj = None
        if renewal_date:
            renewal_date_obj = datetime.strptime(renewal_date, "%Y-%m-%d %H:%M:%S")
        
        # Create new Company object
        company = Company(
            company_id=company_id,
            name=name,
            main_contact_id=main_contact_id,
            target_funding=target_funding,
            grant_type=grant_type,
            status=status,
            renewal_date=renewal_date_obj
        )
        
        # Insert into database
        success = self.database.insert_record(Company.db_table_names(), company.to_record())
        
        if not success:
            raise ValueError("Failed to add company to database")
        
        # Add to cache
        self.companies[company_id] = company
        
        return company

    def remove_company(self, company_id: int) -> bool:
        """
        Remove a company from self.companies (if exists).
        Remove it from self.database using delete_record() function
        Return True if successfully removed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(Company.db_table_names(), company_id)
        
        if success:
            # Remove from cache if present
            if company_id in self.companies:
                del self.companies[company_id]
            
            # Also remove associated company notes from cache
            if company_id in self.company_notes:
                del self.company_notes[company_id]
            
            return True
        
        return False

    def update_company(self, company_id: int, **kwargs) -> Company:
        """
        First get_company() and then update its corresponding attribute values based on **kwargs.
        You also need to update this company in self.database using update_record() function
        Return the updated Company, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Get the company
        company = self.get_company(company_id)
        
        # Convert renewal_date string to datetime if it exists in kwargs
        if 'renewal_date' in kwargs and kwargs['renewal_date']:
            if isinstance(kwargs['renewal_date'], str):
                kwargs['renewal_date'] = datetime.strptime(kwargs['renewal_date'], "%Y-%m-%d %H:%M:%S")
        
        # Update company attributes
        company.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Company.db_table_names(), company.to_record())
        
        if not success:
            raise ValueError(f"Failed to update company with ID {company_id}")
        
        # Update in cache
        self.companies[company_id] = company
        
        return company

    def get_company_notes(self, company_id: int, order_by_create_date: bool=True) -> t.List[CompanyNote]:
        """
        Return a list of company notes.
        Write and execute a SQL query in postgres syntax to retrieve all company notes (with all columns)
            with company_notes.company_id = company_id.
        If order_by_create_date is true, sort by 'create_time' column in descending order
        Add the retrieved company notes to self.company_notes and return them.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"SELECT * FROM company_notes WHERE company_id = {company_id}"
        
        if order_by_create_date:
            query += " ORDER BY create_time DESC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        notes = []
        if results:
            for note_data in results:
                note_id = note_data[0]       # Assuming note_id is the 1st column
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time_str = note_data[2]   # Assuming create_time is the 3rd column
                
                # Convert string date to datetime if not None
                create_time = None
                if create_time_str:
                    create_time = datetime.strptime(create_time_str, "%Y-%m-%d %H:%M:%S")
                
                # Create CompanyNote object
                company_note = CompanyNote(
                    company_note_id=note_id,
                    company_id=company_id,
                    note=note_text,
                    create_time=create_time
                )
                notes.append(company_note)
        
        # Add to cache
        self.company_notes[company_id] = notes
        
        return notes

    def add_company_note(self,
                         company_id: int,
                         new_note: str,
                         create_time: str = '',
                         company_note_id: Optional[int] = None) -> CompanyNote:
        """
        If company_note_id is None or -1, we will create a new company_note_id using HashFunc.hash_company_note_id()
        Create a new CompanyNote object.
        Add it to self.company_notes and insert it into the database using insert_record() function
        Return the newly created CompanyNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate note ID if not provided
        if company_note_id is None or company_note_id == -1:
            company_note_id = HashFunc.hash_company_note_id(company_id, new_note)
        
        # Set create time if not provided
        create_time_obj = None
        if create_time:
            create_time_obj = datetime.strptime(create_time, "%Y-%m-%d %H:%M:%S")
        else:
            create_time_obj = datetime.now()
        
        # Create new CompanyNote object
        company_note = CompanyNote(
            company_note_id=company_note_id,
            company_id=company_id,
            note=new_note,
            create_time=create_time_obj
        )
        
        # Insert into database
        success = self.database.insert_record(CompanyNote.db_table_names(), company_note.to_record())
        
        if not success:
            raise ValueError("Failed to add company note to database")
        
        # Add to cache
        if company_id not in self.company_notes:
            self.company_notes[company_id] = []
        self.company_notes[company_id].append(company_note)
        
        return company_note

    def remove_company_note(self, company_id: int, company_note_id: int) -> bool:
        """
        Remove a company note with company_id and company_note_id.
        If it exists in self.company_notes, remove it.
        Remove company note from self.database using delete_record() function
        Return True if successfully removed.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(CompanyNote.db_table_names(), company_note_id)
        
        if success:
            # Remove from cache if present
            if company_id in self.company_notes:
                self.company_notes[company_id] = [
                    note for note in self.company_notes[company_id] 
                    if note.company_note_id != company_note_id
                ]
            
            return True
        
        return False

    def update_company_note(self, company_id: int, company_note_id: int, new_note: str) -> CompanyNote:
        """
        First get the CompanyNote object with company_id, company_note_id from self.company_notes or self.database.
        Then update its note with new_note.
        You also need to update this company note in self.database using update_record() function
        Return the updated CompanyNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Find the note in cache
        company_note = None
        if company_id in self.company_notes:
            for note in self.company_notes[company_id]:
                if note.company_note_id == company_note_id:
                    company_note = note
                    break
        
        # If not in cache, query from database
        if not company_note:
            query = f"SELECT * FROM company_notes WHERE company_note_id = {company_note_id}"
            result = self.database.execute_query(query)
            
            if result and len(result) > 0:
                note_data = result[0]
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time_str = note_data[2]   # Assuming create_time is the 3rd column
                
                # Convert string date to datetime if not None
                create_time = None
                if create_time_str:
                    create_time = datetime.strptime(create_time_str, "%Y-%m-%d %H:%M:%S")
                
                company_note = CompanyNote(
                    company_note_id=company_note_id,
                    company_id=company_id,
                    note=note_text,
                    create_time=create_time
                )
        
        if not company_note:
            raise ValueError(f"Company note with ID {company_note_id} not found")
        
        # Update note text
        company_note.update_attribute(note=new_note)
        
        # Update in database
        success = self.database.update_record(CompanyNote.db_table_names(), company_note.to_record())
        
        if not success:
            raise ValueError(f"Failed to update company note with ID {company_note_id}")
        
        # Update in cache
        if company_id in self.company_notes:
            for i, note in enumerate(self.company_notes[company_id]):
                if note.company_note_id == company_note_id:
                    self.company_notes[company_id][i] = company_note
                    break
        
        return company_note

    def get_all_contacts(self, sort_by_companies: bool = True):
        """
        Return all contacts assigned to the current agent.
        Write and execute a SQL query in postgres syntax to retrieve all contacts (with all columns) with contacts.assigned_agent_id = self.agent_id
        If group_by_companies is true, sort by 'company_id' column
        Returns:
            Store the retrieved contacts in dictionary self.contacts
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        if self.agent_id is None:
            raise ValueError("Agent ID not set")
        
        # Build the query
        query = f"SELECT * FROM contacts WHERE assigned_agent_id = {self.agent_id}"
        
        if sort_by_companies:
            query += " ORDER BY company_id"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        # Clear existing contacts cache
        self.contacts.clear()
        
        if results:
            for contact_data in results:
                contact_id = contact_data[0]      # Assuming contact_id is the 1st column
                name = contact_data[1]            # Assuming name is the 2nd column
                email = contact_data[2]           # Assuming email is the 3rd column
                company_id = contact_data[3]      # Assuming company_id is the 4th column
                assigned_agent_id = contact_data[4]  # Assuming assigned_agent_id is the 5th column
                status = contact_data[5]          # Assuming status is the 6th column
                
                contact = Contact(
                    contact_id=contact_id,
                    name=name,
                    email=email,
                    company_id=company_id,
                    assigned_agent_id=assigned_agent_id,
                    status=status
                )
                
                self.contacts[contact_id] = contact

    def get_contact(self, contact_id: int) -> Contact:
        """
        Return the contact with id 'contact_id'.
        First check in self.contacts.
        If not found, search in self.database. If not found in database, raise error.
        Add the contact to self.contacts and return it.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if contact is in cache
        if contact_id in self.contacts:
            return self.contacts[contact_id]
        
        # Query the database for this contact
        query = f"SELECT * FROM contacts WHERE contact_id = {contact_id}"
        result = self.database.execute_query(query)
        
        if result and len(result) > 0:
            contact_data = result[0]
            name = contact_data[1]            # Assuming name is the 2nd column
            email = contact_data[2]           # Assuming email is the 3rd column
            company_id = contact_data[3]      # Assuming company_id is the 4th column
            assigned_agent_id = contact_data[4]  # Assuming assigned_agent_id is the 5th column
            status = contact_data[5]          # Assuming status is the 6th column
            
            contact = Contact(
                contact_id=contact_id,
                name=name,
                email=email,
                company_id=company_id,
                assigned_agent_id=assigned_agent_id,
                status=status
            )
            
            # Add to cache
            self.contacts[contact_id] = contact
            return contact
        
        raise ValueError(f"Contact with ID {contact_id} not found")

    def add_contact(self,
                    name: str,
                    email: str,
                    company_id: int,
                    assigned_agent_id: int = -1,
                    status: str = 'new',
                    contact_id: Optional[int] = None) -> Contact:
        """
        If contact_id is None or -1, we will create a new contact_id using HashFunc.hash_contact_id()
        Create a new Contact object.
        Add it to self.contacts and insert it into the database using insert_record() function
        Return the newly created Contact, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Use current agent ID if not specified
        if assigned_agent_id == -1 and self.agent_id is not None:
            assigned_agent_id = self.agent_id
        elif assigned_agent_id == -1:
            raise ValueError("Agent ID not set and no assigned_agent_id provided")
        
        # Generate contact ID if not provided
        if contact_id is None or contact_id == -1:
            contact_id = HashFunc.hash_contact_id(name, email, company_id)
        
        # Create new Contact object
        contact = Contact(
            contact_id=contact_id,
            name=name,
            email=email,
            company_id=company_id,
            assigned_agent_id=assigned_agent_id,
            status=status
        )
        
        # Insert into database
        success = self.database.insert_record(Contact.db_table_names(), contact.to_record())
        
        if not success:
            raise ValueError("Failed to add contact to database")
        
        # Add to cache
        self.contacts[contact_id] = contact
        
        return contact

    def remove_contact(self, contact_id: int) -> bool:
        """
        Remove the contact from self.contact (if exists).
        Remove it from self.database using delete_record() function
        Return True if successfully removed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(Contact.db_table_names(), contact_id)
        
        if success:
            # Remove from cache if present
            if contact_id in self.contacts:
                del self.contacts[contact_id]
            
            # Also remove associated contact notes from cache
            if contact_id in self.contact_notes:
                del self.contact_notes[contact_id]
            
            return True
        
        return False

    def update_contact(self, contact_id: int, **kwargs) -> Contact:
        """
        First get_contact() and then update its corresponding attribute values based on **kwargs.
        You also need to update this contact in self.database using update_record() function
        Return the updated Contact, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Get the contact
        contact = self.get_contact(contact_id)
        
        # Update contact attributes
        contact.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Contact.db_table_names(), contact.to_record())
        
        if not success:
            raise ValueError(f"Failed to update contact with ID {contact_id}")
        
        # Update in cache
        self.contacts[contact_id] = contact
        
        return contact

    def get_contact_notes(self, contact_id: int, order_by_create_date: bool = True) -> t.List[ContactNote]:
        """
        Return a list of contact notes.
        Write and execute a SQL query in postgres syntax to retrieve all contact notes (with all columns)
            with contact_notes.contact_id = contact_id.
        If order_by_create_date is true, sort by 'create_time' column in descending order
        Add the retrieve contact notes to self.contact_notes and return them.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Build the query
        query = f"SELECT * FROM contact_notes WHERE contact_id = {contact_id}"
        
        if order_by_create_date:
            query += " ORDER BY create_time DESC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        notes = []
        if results:
            for note_data in results:
                note_id = note_data[0]       # Assuming note_id is the 1st column
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time_str = note_data[2]   # Assuming create_time is the 3rd column
                assigned_agent_id = note_data[4]  # Assuming assigned_agent_id is the 5th column
                
                # Convert string date to datetime if not None
                create_time = None
                if create_time_str:
                    create_time = datetime.strptime(create_time_str, "%Y-%m-%d %H:%M:%S")
                
                # Create ContactNote object
                contact_note = ContactNote(
                    contact_note_id=note_id,
                    contact_id=contact_id,
                    note=note_text,
                    create_time=create_time,
                    assigned_agent_id=assigned_agent_id
                )
                notes.append(contact_note)
        
        # Add to cache
        self.contact_notes[contact_id] = notes
        
        return notes

    def add_contact_note(self,
                         contact_id: int,
                         new_note: str,
                         assigned_agent_id: int,
                         create_time: str = '',
                         contact_note_id: Optional[int] = None) -> ContactNote:
        """
        If contact_note_id is None or -1, we will create a new contact_note_id using HashFunc.hash_contact_note_id()
        Create a new ContactNote object.
        Add it to self.contact_notes and insert it into the database using insert_record() function
        Return the newly created ContactNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate note ID if not provided
        if contact_note_id is None or contact_note_id == -1:
            contact_note_id = HashFunc.hash_contact_note_id(contact_id, new_note)
        
        # Set create time if not provided
        create_time_obj = None
        if create_time:
            create_time_obj = datetime.strptime(create_time, "%Y-%m-%d %H:%M:%S")
        else:
            create_time_obj = datetime.now()
        
        # Create new ContactNote object
        contact_note = ContactNote(
            contact_note_id=contact_note_id,
            contact_id=contact_id,
            note=new_note,
            create_time=create_time_obj,
            assigned_agent_id=assigned_agent_id
        )
        
        # Insert into database
        success = self.database.insert_record(ContactNote.db_table_names(), contact_note.to_record())
        
        if not success:
            raise ValueError("Failed to add contact note to database")
        
        # Add to cache
        if contact_id not in self.contact_notes:
            self.contact_notes[contact_id] = []
        self.contact_notes[contact_id].append(contact_note)
        
        return contact_note

    def remove_contact_note(self, contact_id: int, contact_note_id: int) -> bool:
        """
        Remove a contact note with contact_id and contact_note_id.
        If it exists in self.contact_notes, remove it.
        Remove company note from self.database using delete_record() function
        Return True if successfully removed.
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(ContactNote.db_table_names(), contact_note_id)
        
        if success:
            # Remove from cache if present
            if contact_id in self.contact_notes:
                self.contact_notes[contact_id] = [
                    note for note in self.contact_notes[contact_id] 
                    if note.contact_note_id != contact_note_id
                ]
            
            return True
        
        return False

    def update_contact_note(self, contact_id: int, contact_note_id: int, **kwargs) -> ContactNote:
        """
        First get the ContactNote object with contact_id, contact_note_id from self.contact_notes or self.database.
        Then update it with **kwargs
        You also need to update this contact note in self.database using update_record() function
        Return the updated ContactNote, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Find the note in cache
        contact_note = None
        if contact_id in self.contact_notes:
            for note in self.contact_notes[contact_id]:
                if note.contact_note_id == contact_note_id:
                    contact_note = note
                    break
        
        # If not in cache, query from database
        if not contact_note:
            query = f"SELECT * FROM contact_notes WHERE contact_note_id = {contact_note_id}"
            result = self.database.execute_query(query)
            
            if result and len(result) > 0:
                note_data = result[0]
                note_text = note_data[1]     # Assuming note is the 2nd column
                create_time_str = note_data[2]   # Assuming create_time is the 3rd column
                assigned_agent_id = note_data[4]  # Assuming assigned_agent_id is the 5th column
                
                # Convert string date to datetime if not None
                create_time = None
                if create_time_str:
                    create_time = datetime.strptime(create_time_str, "%Y-%m-%d %H:%M:%S")
                
                contact_note = ContactNote(
                    contact_note_id=contact_note_id,
                    contact_id=contact_id,
                    note=note_text,
                    create_time=create_time,
                    assigned_agent_id=assigned_agent_id
                )
        
        if not contact_note:
            raise ValueError(f"Contact note with ID {contact_note_id} not found")
        
        # Update note attributes
        contact_note.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(ContactNote.db_table_names(), contact_note.to_record())
        
        if not success:
            raise ValueError(f"Failed to update contact note with ID {contact_note_id}")
        
        # Update in cache
        if contact_id in self.contact_notes:
            for i, note in enumerate(self.contact_notes[contact_id]):
                if note.contact_note_id == contact_note_id:
                    self.contact_notes[contact_id][i] = contact_note
                    break
        
        return contact_note

    def get_all_tasks(self, order_by_due_date: bool = True):
        """
        Return all tasks assigned to the current agent.
        Write and execute a SQL query in postgres syntax to retrieve all tasks (with all columns) with tasks.assigned_to = self.agent_id
        If order_by_due_date is true, add a sort statement on 'due_time' column to the SQL (in ascending order)
        Store the retrieved tasks in dictionary self.tasks
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        if self.agent_id is None:
            raise ValueError("Agent ID not set")
        
        # Build the query
        query = f"SELECT * FROM tasks WHERE assigned_agent_id = {self.agent_id}"
        
        if order_by_due_date:
            query += " ORDER BY due_time ASC"
        
        # Execute the query
        results = self.database.execute_query(query)
        
        # Clear existing tasks cache
        self.tasks.clear()
        
        if results:
            for task_data in results:
                task_id = task_data[0]           # Assuming task_id is the 1st column
                name = task_data[1]              # Assuming name is the 2nd column
                assigned_agent_id = task_data[2]  # Assuming assigned_agent_id is the 3rd column
                contact_id = task_data[3]        # Assuming contact_id is the 4th column
                company_id = task_data[4]        # Assuming company_id is the 5th column
                description = task_data[5]       # Assuming description is the 6th column
                due_time_str = task_data[7]      # Assuming due_time is the 8th column
                status = task_data[8]            # Assuming status is the 9th column
                
                # Convert string date to datetime if not None
                due_time = None
                if due_time_str:
                    due_time = datetime.strptime(due_time_str, "%Y-%m-%d %H:%M:%S")
                
                task = Task(
                    task_id=task_id,
                    name=name,
                    assigned_agent_id=assigned_agent_id,
                    contact_id=contact_id,
                    company_id=company_id,
                    description=description,
                    due_time=due_time,
                    status=status
                )
                
                self.tasks[task_id] = task

    def add_task(self,
                 assigned_agent_id: int,
                 contact_id: int,
                 company_id: int,
                 name: str,
                 description: str,
                 create_time: str = '',
                 due_time: str = '',
                 status: str = 'incomplete',
                 task_id: Optional[int] = None) -> Task:
        """
        If task_id is None or -1, we will create a new task_id using HashFunc.hash_task_id()
        Create a new Task object.
        Add it to self.tasks (preserving the descending order by due_time) and insert it into the database using insert_record() function
        Return the newly created Task, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Generate task ID if not provided
        if task_id is None or task_id == -1:
            task_id = HashFunc.hash_task_id(assigned_agent_id, contact_id, company_id, name)
        
        # Convert string date to datetime if not None
        due_time_obj = None
        if due_time:
            due_time_obj = datetime.strptime(due_time, "%Y-%m-%d %H:%M:%S")
        
        # Create new Task object
        task = Task(
            task_id=task_id,
            name=name,
            assigned_agent_id=assigned_agent_id,
            contact_id=contact_id,
            company_id=company_id,
            description=description,
            due_time=due_time_obj,
            status=status
        )
        
        # Insert into database
        success = self.database.insert_record(Task.db_table_names(), task.to_record())
        
        if not success:
            raise ValueError("Failed to add task to database")
        
        # Add to cache
        self.tasks[task_id] = task
        
        return task

    def remove_task(self, task_id: int) -> bool:
        """
        Remove the contact from self.tasks (if exists).
        Remove it from self.database using delete_record() function
        Return True if successfully removed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Remove from database
        success = self.database.delete_record(Task.db_table_names(), task_id)
        
        if success:
            # Remove from cache if present
            if task_id in self.tasks:
                del self.tasks[task_id]
            
            return True
        
        return False

    def update_task(self, task_id: int, **kwargs) -> Task:
        """
        First get_task() and then update its corresponding attribute values based on **kwargs.
        You also need to update this task in self.database using update_record() function
        Return the updated Task, raise error if failed
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if task exists in cache
        if task_id in self.tasks:
            task = self.tasks[task_id]
        else:
            # Query the database for this task
            query = f"SELECT * FROM tasks WHERE task_id = {task_id}"
            result = self.database.execute_query(query)
            
            if not result or len(result) == 0:
                raise ValueError(f"Task with ID {task_id} not found")
                
            task_data = result[0]
            name = task_data[1]              # Assuming name is the 2nd column
            assigned_agent_id = task_data[2]  # Assuming assigned_agent_id is the 3rd column
            contact_id = task_data[3]        # Assuming contact_id is the 4th column
            company_id = task_data[4]        # Assuming company_id is the 5th column
            description = task_data[5]       # Assuming description is the 6th column
            due_time_str = task_data[7]      # Assuming due_time is the 8th column
            status = task_data[8]            # Assuming status is the 9th column
            
            # Convert string date to datetime if not None
            due_time = None
            if due_time_str:
                due_time = datetime.strptime(due_time_str, "%Y-%m-%d %H:%M:%S")
            
            task = Task(
                task_id=task_id,
                name=name,
                assigned_agent_id=assigned_agent_id,
                contact_id=contact_id,
                company_id=company_id,
                description=description,
                due_time=due_time,
                status=status
            )
            self.tasks[task_id] = task
        
        # Convert due_time string to datetime if it exists in kwargs
        if 'due_time' in kwargs and kwargs['due_time']:
            if isinstance(kwargs['due_time'], str):
                kwargs['due_time'] = datetime.strptime(kwargs['due_time'], "%Y-%m-%d %H:%M:%S")
        
        # Update task attributes
        task.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Task.db_table_names(), task.to_record())
        
        if not success:
            raise ValueError(f"Failed to update task with ID {task_id}")
        
        # Update in cache
        self.tasks[task_id] = task
        
        return task

    def show_all_email_templates(self) -> t.List[EmailTemplate]:
        """
        Retrieve all email templates.
        If self.email_templates is None, you need to write and execute a SQL query in postgres syntax to retrieve all email templates and add them to self.email_templates
        Return list of all EmailTemplate
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        # Check if we need to fetch from database
        if not self.email_templates:
            # Query all email templates from the database
            query = "SELECT * FROM email_templates"
            results = self.database.execute_query(query)
            
            if results:
                for template_data in results:
                    template_id = template_data[0]       # Assuming template_id is the 1st column
                    email_subject = template_data[1]     # Assuming email_subject is the 2nd column
                    email_text = template_data[2]        # Assuming email_text is the 3rd column
                    
                    template = EmailTemplate(
                        template_id=template_id,
                        email_subject=email_subject,
                        email_text=email_text
                    )
                    self.email_templates[template_id] = template
        
        # Return all email templates from cache
        return list(self.email_templates.values())

    def send_email(self, contact_id: int, email_subject: str, email_content: str) -> bool:
        """
        Add a new contact note using add_contact_note()
              kwargs = {"contact_id": contact_id,
                        "assigned_agent_id": self.agent_id,
                        "subject": "Sending email with subject: " + email_subject,
                        "note" = email_content
                        }
        Get the email address of the current agent and the email of contact with id 'contact_id'.
        Send an email from agent to contact
        """
        if not self.logged_in:
            raise ValueError("Agent not logged in")
        
        if self.agent_id is None:
            raise ValueError("Agent ID not set")
        
        # Get the contact to find their email
        contact = self.get_contact(contact_id)
        if not contact:
            return False
        
        # Add a note about the email
        note_text = f"Sending email with subject: {email_subject}

{email_content}"
        self.add_contact_note(
            contact_id=contact_id,
            new_note=note_text,
            assigned_agent_id=self.agent_id
        )
        
        # In a real system, this would send an actual email
        # For this implementation, we'll just return True to indicate success
        # Simulate sending email from self.agent.email to contact.email
        
        return True

    def free(self):
        """
        Empty all local caches, self.tasks, self.companies, self.contacts, etc.
        """
        self.companies.clear()
        self.company_notes.clear()
        self.contacts.clear()
        self.contact_notes.clear()
        self.tasks.clear()
        self.email_templates.clear()

Review:

# Transpilation Review
The transpilation of the AgentService class appears to be correct and should compile successfully. The implementation follows the expected structure and functionality described in the class docstrings.

The code properly implements:
- Authentication methods (login, logout, forget_password)
- Company and company note management
- Contact and contact note management
- Task management
- Email template handling

All methods check for login status before performing operations, and the caching mechanism is implemented correctly.

## Compilation Review
No compilation errors are expected. The code follows Python syntax rules and properly uses the imported classes and interfaces.

## Testing Review
No testing issues are expected from this file itself. The implementation follows the specifications and handles error cases appropriately.

## Dependency Analysis Review
The dependency analysis is correct and complete. The file correctly imports:
- datetime for timestamp handling
- typing for type annotations
- HashFunc for ID generation
- Data model classes (Company, CompanyNote, Contact, ContactNote, Agent, Task, EmailTemplate)
- Schema and PostgresOperations for database operations

All dependencies are relevant and necessary for the implementation. The code properly uses these dependencies throughout the implementation.


In your response, describe what step is the root cause of the wrong code generation (i.e., after which step what the LLM chain not able to recover --- e.g, because it's too vaguely or badly planned, or the LLM generated incorrect code although the task was perfectly clear). First, reason about what went wrong in the generation process. Then, describe where it went wrong first. Then describe what is necessary to avoid this failure.
