I'll help you iteratively plan the backend_services.agent_service file. Let's start with the first iteration.

<iteration_state>
```md
# Performed Steps
In this first iteration, I've implemented:
1. All imports at the top of the file
2. The AgentService class with its constructor
3. Authentication methods (login, forget_password, logout, show_setting)
4. The free() utility method

## Full Completions
- Imports: Added all necessary imports
- AgentService.__init__: Implemented the constructor with all necessary member variables
- AgentService.login: Implemented the login method to authenticate an agent
- AgentService.forget_password: Implemented the password recovery method
- AgentService.logout: Implemented the logout method
- AgentService.show_setting: Implemented the method to return agent settings
- AgentService.free: Implemented the method to clear all caches

## Untouched Nodes
All other methods in the AgentService class remain untouched. These include:
- Company-related methods (get_all_companies, show_all_company_contacts, etc.)
- Company note methods (get_company_notes, add_company_note, etc.)
- Contact-related methods (get_all_contacts, get_contact, etc.)
- Contact note methods (get_contact_notes, add_contact_note, etc.)
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the company-related methods and company note methods.

## Next to Plan
- get_all_companies
- show_all_company_contacts
- show_all_company_tasks
- get_company
- add_company
- remove_company
- update_company
- get_company_notes
- add_company_note
- remove_company_note
- update_company_note

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns but require careful handling of database operations and cache management.
```
</iteration_state>

<top_statements>
```py
from datetime import datetime
import typing as t
from .utils import HashFunc
from .data_models import Company, CompanyNote, Contact, ContactNote, Agent, Task, EmailTemplate
from database.schema import Schema
from database.db_operations import PostgresOperations
```
</top_statements>

<next_plan>
```py
class AgentService:
    """
    Interface for all services related to an agent.
    """

    def __init__(self, schema: Schema, database: PostgresOperations):
        """
        Initialize the agent service with schema and database connection.
        """
        self.agent_id = None
        self.agent = None
        self.logged_in = False   # In every of following methods expect self.login() and self.forget_password(), raise error if not logged_in
        # this serves as a temporary cache
        self.companies: t.Dict[int, Company] = dict()     # a dictionary company_id: Company
        self.company_notes: t.Dict[int, t.List[CompanyNote]] = dict()   # a dictionary company_id: list of CompanyNote
        self.contacts: t.Dict[int, Contact] = dict()  # a dictionary contact_id: Contact
        self.contact_notes: t.Dict[int, t.List[ContactNote]] = dict()  # a dictionary contact_id: ContactNote
        self.tasks: t.Dict[int, Task] = dict()  # a dictionary task_id: Task
        self.email_templates: t.Dict[int, EmailTemplate] = dict()   # a dictionary template_id: list of EmailTemplate
        self.schema = schema
        self.database = database

    def login(self, agent_id: int, agent_email: str, password: str) -> bool:
        """
        An agent can login using id or email, that allows him/her to perform different functionalities.
        """
        # Check if agent exists by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if not result:
            return False
        
        # Check if password matches
        agent_data = result[0]  # First row of results
        stored_password = agent_data[3]  # Assuming password is the 4th column
        
        if password != stored_password:
            return False
        
        # Create Agent object from result
        self.agent = Agent(
            agent_id=agent_data[0],
            name=agent_data[1],
            email=agent_data[2],
            password=agent_data[3]
        )
        
        self.agent_id = self.agent.agent_id
        self.logged_in = True
        
        # Load initial data
        self.get_all_tasks()
        self.get_all_contacts()
        self.get_all_companies()
        
        return True

    def forget_password(self, agent_id: int, agent_email: str) -> bool:
        """
        If agent_id or agent_email exists in the database, send an email with agent's current password to agent's email.
        """
        # Check if agent exists by ID or email
        query = f"SELECT * FROM agents WHERE agent_id = {agent_id} OR email = '{agent_email}'"
        result = self.database.execute_query(query)
        
        if not result:
            return False
        
        agent_data = result[0]  # First row of results
        agent_email = agent_data[2]  # Assuming email is the 3rd column
        password = agent_data[3]  # Assuming password is the 4th column
        
        # Send email with password to agent's email
        # In a real implementation, this would use an email service
        print(f"Sending password recovery email to {agent_email} with password: {password}")
        
        return True

    def logout(self):
        """
        Set self.logged_in to False and call self.free()
        """
        self.logged_in = False
        self.free()

    def show_setting(self) -> Agent:
        """
        Return self.agent
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        return self.agent

    def free(self):
        """
        Empty all local caches, self.tasks, self.companies, self.contacts, etc.
        """
        self.companies.clear()
        self.company_notes.clear()
        self.contacts.clear()
        self.contact_notes.clear()
        self.tasks.clear()
        self.email_templates.clear()
```
</next_plan>

<structured_iteration_state>
```toml
feasible = true
file_fully_complete = false
missing_dependencies = false
irrelevant_dependencies = false
iteration_difficulty = "medium"
iteration_state = """
# Performed Steps
In this first iteration, I've implemented:
1. All imports at the top of the file
2. The AgentService class with its constructor
3. Authentication methods (login, forget_password, logout, show_setting)
4. The free() utility method

## Full Completions
- Imports: Added all necessary imports
- AgentService.__init__: Implemented the constructor with all necessary member variables
- AgentService.login: Implemented the login method to authenticate an agent
- AgentService.forget_password: Implemented the password recovery method
- AgentService.logout: Implemented the logout method
- AgentService.show_setting: Implemented the method to return agent settings
- AgentService.free: Implemented the method to clear all caches

## Untouched Nodes
All other methods in the AgentService class remain untouched. These include:
- Company-related methods (get_all_companies, show_all_company_contacts, etc.)
- Company note methods (get_company_notes, add_company_note, etc.)
- Contact-related methods (get_all_contacts, get_contact, etc.)
- Contact note methods (get_contact_notes, add_contact_note, etc.)
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the company-related methods and company note methods.

## Next to Plan
- get_all_companies
- show_all_company_contacts
- show_all_company_tasks
- get_company
- add_company
- remove_company
- update_company
- get_company_notes
- add_company_note
- remove_company_note
- update_company_note

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns but require careful handling of database operations and cache management.
"""
dedicated_nodes = []
incomplete_nodes = [
    "get_all_companies",
    "show_all_company_contacts",
    "show_all_company_tasks",
    "get_company",
    "add_company",
    "remove_company",
    "update_company",
    "get_company_notes",
    "add_company_note",
    "remove_company_note",
    "update_company_note",
    "get_all_contacts",
    "get_contact",
    "add_contact",
    "remove_contact",
    "update_contact",
    "get_contact_notes",
    "add_contact_note",
    "remove_contact_note",
    "update_contact_note",
    "get_all_tasks",
    "add_task",
    "remove_task",
    "update_task",
    "show_all_email_templates",
    "send_email"
]
```
</structured_iteration_state>

Let's continue with the next iteration to implement the company-related methods:

<iteration_state>
```md
# Performed Steps
In this iteration, I've implemented:
1. All company-related methods (get_all_companies, show_all_company_contacts, show_all_company_tasks, get_company, add_company, remove_company, update_company)
2. All company note methods (get_company_notes, add_company_note, remove_company_note, update_company_note)

## Full Completions
- get_all_companies: Implemented to retrieve all companies assigned to the current agent
- show_all_company_contacts: Implemented to find all contacts associated with a company
- show_all_company_tasks: Implemented to find all tasks associated with a company
- get_company: Implemented to retrieve a company by ID from cache or database
- add_company: Implemented to create a new company and add it to cache and database
- remove_company: Implemented to remove a company from cache and database
- update_company: Implemented to update a company's attributes in cache and database
- get_company_notes: Implemented to retrieve all notes for a company
- add_company_note: Implemented to create a new company note and add it to cache and database
- remove_company_note: Implemented to remove a company note from cache and database
- update_company_note: Implemented to update a company note in cache and database

## Untouched Nodes
The following methods remain untouched:
- Contact-related methods (get_all_contacts, get_contact, etc.)
- Contact note methods (get_contact_notes, add_contact_note, etc.)
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the contact-related methods and contact note methods.

## Next to Plan
- get_all_contacts
- get_contact
- add_contact
- remove_contact
- update_contact
- get_contact_notes
- add_contact_note
- remove_contact_note
- update_contact_note

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns to the company-related methods but with different data models.
```
</iteration_state>

<next_plan>
```py
class AgentService:
    """
    Interface for all services related to an agent.
    """

    def __init__(self, schema: Schema, database: PostgresOperations):
        """
        Initialize the agent service with schema and database connection.
        """
        self.agent_id = None
        self.agent = None
        self.logged_in = False   # In every of following methods expect self.login() and self.forget_password(), raise error if not logged_in
        # this serves as a temporary cache
        self.companies: t.Dict[int, Company] = dict()     # a dictionary company_id: Company
        self.company_notes: t.Dict[int, t.List[CompanyNote]] = dict()   # a dictionary company_id: list of CompanyNote
        self.contacts: t.Dict[int, Contact] = dict()  # a dictionary contact_id: Contact
        self.contact_notes: t.Dict[int, t.List[ContactNote]] = dict()  # a dictionary contact_id: ContactNote
        self.tasks: t.Dict[int, Task] = dict()  # a dictionary task_id: Task
        self.email_templates: t.Dict[int, EmailTemplate] = dict()   # a dictionary template_id: list of EmailTemplate
        self.schema = schema
        self.database = database

    def get_all_companies(self, order_by_target_funding: bool):
        """
        Return all companies assigned to the current agent.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Build SQL query to get companies associated with contacts assigned to this agent
        query = f"""
            SELECT DISTINCT c.* 
            FROM companies c 
            JOIN contacts ct ON c.company_id = ct.company_id 
            WHERE ct.assigned_agent_id = {self.agent_id}
        """
        
        if order_by_target_funding:
            query += " ORDER BY c.target_funding DESC"
        
        result = self.database.execute_query(query)
        
        # Clear existing companies cache
        self.companies.clear()
        
        # Process results and populate companies cache
        for company_data in result:
            company_id = company_data[0]  # Assuming company_id is the first column
            company = Company(
                company_id=company_id,
                name=company_data[1],
                main_contact_id=company_data[2],
                target_funding=company_data[3],
                grant_type=company_data[4],
                status=company_data[5],
                renewal_date=company_data[6]
            )
            self.companies[company_id] = company

    def show_all_company_contacts(self, company_id: int) -> t.List[Contact]:
        """
        Loop through self.contacts and find all contacts associated with this company.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        company_contacts = []
        for contact in self.contacts.values():
            if contact.company_id == company_id:
                company_contacts.append(contact)
        
        return company_contacts

    def show_all_company_tasks(self, company_id: int, order_by_due_date: bool = True) -> t.List[Task]:
        """
        Loop through self.tasks and find all tasks associated with this company.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        company_tasks = []
        for task in self.tasks.values():
            if task.company_id == company_id:
                company_tasks.append(task)
        
        if order_by_due_date:
            company_tasks.sort(key=lambda task: task.due_time, reverse=True)
        
        return company_tasks

    def get_company(self, company_id: int) -> Company:
        """
        Return the company with id 'company_id'.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Check if company exists in cache
        if company_id in self.companies:
            return self.companies[company_id]
        
        # If not in cache, query the database
        query = f"SELECT * FROM companies WHERE company_id = {company_id}"
        result = self.database.execute_query(query)
        
        if not result:
            raise Exception(f"Company with id {company_id} not found")
        
        company_data = result[0]
        company = Company(
            company_id=company_data[0],
            name=company_data[1],
            main_contact_id=company_data[2],
            target_funding=company_data[3],
            grant_type=company_data[4],
            status=company_data[5],
            renewal_date=company_data[6]
        )
        
        # Add to cache
        self.companies[company_id] = company
        
        return company

    def add_company(self,
                    name: str,
                    main_contact_id: int,
                    target_funding: float,
                    grant_type: str = "",
                    status: str = "New",
                    renewal_date: str = "",
                    company_id: int = None,
                    ) -> Company:
        """
        Create a new Company object.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Generate company_id if not provided
        if company_id is None or company_id == -1:
            company_id = HashFunc.hash_company_id(name, main_contact_id, int(target_funding))
        
        # Create new company object
        company = Company(
            company_id=company_id,
            name=name,
            main_contact_id=main_contact_id,
            target_funding=target_funding,
            grant_type=grant_type,
            status=status,
            renewal_date=renewal_date
        )
        
        # Add to cache
        self.companies[company_id] = company
        
        # Insert into database
        success = self.database.insert_record(Company.db_table_names(), company.to_record())
        
        if not success:
            raise Exception("Failed to add company to database")
        
        return company

    def remove_company(self, company_id: int) -> bool:
        """
        Remove a company from self.companies (if exists).
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Remove from cache if exists
        if company_id in self.companies:
            del self.companies[company_id]
        
        # Remove from database
        success = self.database.delete_record(Company.db_table_names(), company_id)
        
        return success

    def update_company(self, company_id: int, **kwargs) -> Company:
        """
        First get_company() and then update its corresponding attribute values based on **kwargs.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Get company
        company = self.get_company(company_id)
        
        # Update attributes
        company.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Company.db_table_names(), company.to_record())
        
        if not success:
            raise Exception("Failed to update company in database")
        
        return company

    def get_company_notes(self, company_id: int, order_by_create_date: bool=True) -> t.List[CompanyNote]:
        """
        Return a list of company notes.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Build SQL query
        query = f"SELECT * FROM company_notes WHERE company_id = {company_id}"
        
        if order_by_create_date:
            query += " ORDER BY create_time DESC"
        
        result = self.database.execute_query(query)
        
        # Process results
        company_notes = []
        for note_data in result:
            note = CompanyNote(
                company_note_id=note_data[0],
                company_id=note_data[1],
                note=note_data[2],
                create_time=note_data[3]
            )
            company_notes.append(note)
        
        # Update cache
        self.company_notes[company_id] = company_notes
        
        return company_notes

    def add_company_note(self,
                         company_id: int,
                         new_note: str,
                         create_time: str = '',
                         company_note_id: int = None) -> CompanyNote:
        """
        Create a new CompanyNote object.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Set create_time if not provided
        if not create_time:
            create_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Generate company_note_id if not provided
        if company_note_id is None or company_note_id == -1:
            company_note_id = HashFunc.hash_company_note_id(company_id, new_note)
        
        # Create new company note
        company_note = CompanyNote(
            company_note_id=company_note_id,
            company_id=company_id,
            note=new_note,
            create_time=create_time
        )
        
        # Add to cache
        if company_id not in self.company_notes:
            self.company_notes[company_id] = []
        self.company_notes[company_id].append(company_note)
        
        # Insert into database
        success = self.database.insert_record(CompanyNote.db_table_names(), company_note.to_record())
        
        if not success:
            raise Exception("Failed to add company note to database")
        
        return company_note

    def remove_company_note(self, company_id: int, company_note_id: int) -> bool:
        """
        Remove a company note with company_id and company_note_id.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Remove from cache if exists
        if company_id in self.company_notes:
            self.company_notes[company_id] = [note for note in self.company_notes[company_id] 
                                             if note.company_note_id != company_note_id]
        
        # Remove from database
        success = self.database.delete_record(CompanyNote.db_table_names(), company_note_id)
        
        return success

    def update_company_note(self, company_id: int, company_note_id: int, new_note: str) -> CompanyNote:
        """
        First get the CompanyNote object with company_id, company_note_id from self.company_notes or self.database.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Find note in cache
        company_note = None
        if company_id in self.company_notes:
            for note in self.company_notes[company_id]:
                if note.company_note_id == company_note_id:
                    company_note = note
                    break
        
        # If not in cache, query database
        if company_note is None:
            query = f"SELECT * FROM company_notes WHERE company_note_id = {company_note_id} AND company_id = {company_id}"
            result = self.database.execute_query(query)
            
            if not result:
                raise Exception(f"Company note with id {company_note_id} not found")
            
            note_data = result[0]
            company_note = CompanyNote(
                company_note_id=note_data[0],
                company_id=note_data[1],
                note=note_data[2],
                create_time=note_data[3]
            )
            
            # Add to cache
            if company_id not in self.company_notes:
                self.company_notes[company_id] = []
            self.company_notes[company_id].append(company_note)
        
        # Update note
        company_note.update_attribute(note=new_note)
        
        # Update in database
        success = self.database.update_record(CompanyNote.db_table_names(), company_note.to_record())
        
        if not success:
            raise Exception("Failed to update company note in database")
        
        return company_note
```
</next_plan>

<structured_iteration_state>
```toml
feasible = true
file_fully_complete = false
missing_dependencies = false
irrelevant_dependencies = false
iteration_difficulty = "medium"
iteration_state = """
# Performed Steps
In this iteration, I've implemented:
1. All company-related methods (get_all_companies, show_all_company_contacts, show_all_company_tasks, get_company, add_company, remove_company, update_company)
2. All company note methods (get_company_notes, add_company_note, remove_company_note, update_company_note)

## Full Completions
- get_all_companies: Implemented to retrieve all companies assigned to the current agent
- show_all_company_contacts: Implemented to find all contacts associated with a company
- show_all_company_tasks: Implemented to find all tasks associated with a company
- get_company: Implemented to retrieve a company by ID from cache or database
- add_company: Implemented to create a new company and add it to cache and database
- remove_company: Implemented to remove a company from cache and database
- update_company: Implemented to update a company's attributes in cache and database
- get_company_notes: Implemented to retrieve all notes for a company
- add_company_note: Implemented to create a new company note and add it to cache and database
- remove_company_note: Implemented to remove a company note from cache and database
- update_company_note: Implemented to update a company note in cache and database

## Untouched Nodes
The following methods remain untouched:
- Contact-related methods (get_all_contacts, get_contact, etc.)
- Contact note methods (get_contact_notes, add_contact_note, etc.)
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the contact-related methods and contact note methods.

## Next to Plan
- get_all_contacts
- get_contact
- add_contact
- remove_contact
- update_contact
- get_contact_notes
- add_contact_note
- remove_contact_note
- update_contact_note

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns to the company-related methods but with different data models.
"""
dedicated_nodes = []
incomplete_nodes = [
    "get_all_contacts",
    "get_contact",
    "add_contact",
    "remove_contact",
    "update_contact",
    "get_contact_notes",
    "add_contact_note",
    "remove_contact_note",
    "update_contact_note",
    "get_all_tasks",
    "add_task",
    "remove_task",
    "update_task",
    "show_all_email_templates",
    "send_email"
]
```
</structured_iteration_state>

Let's continue with the next iteration to implement the contact-related methods:

<iteration_state>
```md
# Performed Steps
In this iteration, I've implemented:
1. All contact-related methods (get_all_contacts, get_contact, add_contact, remove_contact, update_contact)
2. All contact note methods (get_contact_notes, add_contact_note, remove_contact_note, update_contact_note)

## Full Completions
- get_all_contacts: Implemented to retrieve all contacts assigned to the current agent
- get_contact: Implemented to retrieve a contact by ID from cache or database
- add_contact: Implemented to create a new contact and add it to cache and database
- remove_contact: Implemented to remove a contact from cache and database
- update_contact: Implemented to update a contact's attributes in cache and database
- get_contact_notes: Implemented to retrieve all notes for a contact
- add_contact_note: Implemented to create a new contact note and add it to cache and database
- remove_contact_note: Implemented to remove a contact note from cache and database
- update_contact_note: Implemented to update a contact note in cache and database

## Untouched Nodes
The following methods remain untouched:
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the task-related methods and email-related methods.

## Next to Plan
- get_all_tasks
- add_task
- remove_task
- update_task
- show_all_email_templates
- send_email

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns to the previously implemented methods but with different data models.
```
</iteration_state>

<next_plan>
```py
class AgentService:
    """
    Interface for all services related to an agent.
    """

    def __init__(self, schema: Schema, database: PostgresOperations):
        """
        Initialize the agent service with schema and database connection.
        """
        self.agent_id = None
        self.agent = None
        self.logged_in = False   # In every of following methods expect self.login() and self.forget_password(), raise error if not logged_in
        # this serves as a temporary cache
        self.companies: t.Dict[int, Company] = dict()     # a dictionary company_id: Company
        self.company_notes: t.Dict[int, t.List[CompanyNote]] = dict()   # a dictionary company_id: list of CompanyNote
        self.contacts: t.Dict[int, Contact] = dict()  # a dictionary contact_id: Contact
        self.contact_notes: t.Dict[int, t.List[ContactNote]] = dict()  # a dictionary contact_id: ContactNote
        self.tasks: t.Dict[int, Task] = dict()  # a dictionary task_id: Task
        self.email_templates: t.Dict[int, EmailTemplate] = dict()   # a dictionary template_id: list of EmailTemplate
        self.schema = schema
        self.database = database

    def get_all_contacts(self, sort_by_companies: bool = True):
        """
        Return all contacts assigned to the current agent.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Build SQL query
        query = f"SELECT * FROM contacts WHERE assigned_agent_id = {self.agent_id}"
        
        if sort_by_companies:
            query += " ORDER BY company_id"
        
        result = self.database.execute_query(query)
        
        # Clear existing contacts cache
        self.contacts.clear()
        
        # Process results and populate contacts cache
        for contact_data in result:
            contact_id = contact_data[0]  # Assuming contact_id is the first column
            contact = Contact(
                contact_id=contact_id,
                name=contact_data[1],
                email=contact_data[2],
                company_id=contact_data[3],
                assigned_agent_id=contact_data[4],
                status=contact_data[5]
            )
            self.contacts[contact_id] = contact

    def get_contact(self, contact_id: int) -> Contact:
        """
        Return the contact with id 'contact_id'.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Check if contact exists in cache
        if contact_id in self.contacts:
            return self.contacts[contact_id]
        
        # If not in cache, query the database
        query = f"SELECT * FROM contacts WHERE contact_id = {contact_id}"
        result = self.database.execute_query(query)
        
        if not result:
            raise Exception(f"Contact with id {contact_id} not found")
        
        contact_data = result[0]
        contact = Contact(
            contact_id=contact_data[0],
            name=contact_data[1],
            email=contact_data[2],
            company_id=contact_data[3],
            assigned_agent_id=contact_data[4],
            status=contact_data[5]
        )
        
        # Add to cache
        self.contacts[contact_id] = contact
        
        return contact

    def add_contact(self,
                    name: str,
                    email: str,
                    company_id: int,
                    assigned_agent_id: int = -1,
                    status: str = 'new',
                    contact_id: int = None) -> Contact:
        """
        Create a new Contact object.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Use current agent_id if not specified
        if assigned_agent_id == -1:
            assigned_agent_id = self.agent_id
        
        # Generate contact_id if not provided
        if contact_id is None or contact_id == -1:
            contact_id = HashFunc.hash_contact_id(name, email, company_id)
        
        # Create new contact object
        contact = Contact(
            contact_id=contact_id,
            name=name,
            email=email,
            company_id=company_id,
            assigned_agent_id=assigned_agent_id,
            status=status
        )
        
        # Add to cache
        self.contacts[contact_id] = contact
        
        # Insert into database
        success = self.database.insert_record(Contact.db_table_names(), contact.to_record())
        
        if not success:
            raise Exception("Failed to add contact to database")
        
        return contact

    def remove_contact(self, contact_id: int) -> bool:
        """
        Remove the contact from self.contact (if exists).
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Remove from cache if exists
        if contact_id in self.contacts:
            del self.contacts[contact_id]
        
        # Remove from database
        success = self.database.delete_record(Contact.db_table_names(), contact_id)
        
        return success

    def update_contact(self, contact_id: int, **kwargs) -> Contact:
        """
        First get_contact() and then update its corresponding attribute values based on **kwargs.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Get contact
        contact = self.get_contact(contact_id)
        
        # Update attributes
        contact.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Contact.db_table_names(), contact.to_record())
        
        if not success:
            raise Exception("Failed to update contact in database")
        
        return contact

    def get_contact_notes(self, contact_id: int, order_by_create_date: bool = True) -> t.List[ContactNote]:
        """
        Return a list of contact notes.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Build SQL query
        query = f"SELECT * FROM contact_notes WHERE contact_id = {contact_id}"
        
        if order_by_create_date:
            query += " ORDER BY create_time DESC"
        
        result = self.database.execute_query(query)
        
        # Process results
        contact_notes = []
        for note_data in result:
            note = ContactNote(
                contact_note_id=note_data[0],
                contact_id=note_data[1],
                assigned_agent_id=note_data[2],
                note=note_data[3],
                create_time=note_data[4]
            )
            contact_notes.append(note)
        
        # Update cache
        self.contact_notes[contact_id] = contact_notes
        
        return contact_notes

    def add_contact_note(self,
                         contact_id: int,
                         new_note: str,
                         assigned_agent_id: int,
                         create_time: str = '',
                         contact_note_id: int = None) -> ContactNote:
        """
        Create a new ContactNote object.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Set create_time if not provided
        if not create_time:
            create_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Generate contact_note_id if not provided
        if contact_note_id is None or contact_note_id == -1:
            contact_note_id = HashFunc.hash_contact_note_id(contact_id, new_note)
        
        # Create new contact note
        contact_note = ContactNote(
            contact_note_id=contact_note_id,
            contact_id=contact_id,
            assigned_agent_id=assigned_agent_id,
            note=new_note,
            create_time=create_time
        )
        
        # Add to cache
        if contact_id not in self.contact_notes:
            self.contact_notes[contact_id] = []
        self.contact_notes[contact_id].append(contact_note)
        
        # Insert into database
        success = self.database.insert_record(ContactNote.db_table_names(), contact_note.to_record())
        
        if not success:
            raise Exception("Failed to add contact note to database")
        
        return contact_note

    def remove_contact_note(self, contact_id: int, contact_note_id: int) -> bool:
        """
        Remove a contact note with contact_id and contact_note_id.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Remove from cache if exists
        if contact_id in self.contact_notes:
            self.contact_notes[contact_id] = [note for note in self.contact_notes[contact_id] 
                                             if note.contact_note_id != contact_note_id]
        
        # Remove from database
        success = self.database.delete_record(ContactNote.db_table_names(), contact_note_id)
        
        return success

    def update_contact_note(self, contact_id: int, contact_note_id: int, **kwargs) -> ContactNote:
        """
        First get the ContactNote object with contact_id, contact_note_id from self.contact_notes or self.database.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Find note in cache
        contact_note = None
        if contact_id in self.contact_notes:
            for note in self.contact_notes[contact_id]:
                if note.contact_note_id == contact_note_id:
                    contact_note = note
                    break
        
        # If not in cache, query database
        if contact_note is None:
            query = f"SELECT * FROM contact_notes WHERE contact_note_id = {contact_note_id} AND contact_id = {contact_id}"
            result = self.database.execute_query(query)
            
            if not result:
                raise Exception(f"Contact note with id {contact_note_id} not found")
            
            note_data = result[0]
            contact_note = ContactNote(
                contact_note_id=note_data[0],
                contact_id=note_data[1],
                assigned_agent_id=note_data[2],
                note=note_data[3],
                create_time=note_data[4]
            )
            
            # Add to cache
            if contact_id not in self.contact_notes:
                self.contact_notes[contact_id] = []
            self.contact_notes[contact_id].append(contact_note)
        
        # Update note attributes
        contact_note.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(ContactNote.db_table_names(), contact_note.to_record())
        
        if not success:
            raise Exception("Failed to update contact note in database")
        
        return contact_note
```
</next_plan>

<structured_iteration_state>
```toml
feasible = true
file_fully_complete = false
missing_dependencies = false
irrelevant_dependencies = false
iteration_difficulty = "medium"
iteration_state = """
# Performed Steps
In this iteration, I've implemented:
1. All contact-related methods (get_all_contacts, get_contact, add_contact, remove_contact, update_contact)
2. All contact note methods (get_contact_notes, add_contact_note, remove_contact_note, update_contact_note)

## Full Completions
- get_all_contacts: Implemented to retrieve all contacts assigned to the current agent
- get_contact: Implemented to retrieve a contact by ID from cache or database
- add_contact: Implemented to create a new contact and add it to cache and database
- remove_contact: Implemented to remove a contact from cache and database
- update_contact: Implemented to update a contact's attributes in cache and database
- get_contact_notes: Implemented to retrieve all notes for a contact
- add_contact_note: Implemented to create a new contact note and add it to cache and database
- remove_contact_note: Implemented to remove a contact note from cache and database
- update_contact_note: Implemented to update a contact note in cache and database

## Untouched Nodes
The following methods remain untouched:
- Task-related methods (get_all_tasks, add_task, etc.)
- Email-related methods (show_all_email_templates, send_email)

# Next Steps
In the next iteration, I'll implement the task-related methods and email-related methods.

## Next to Plan
- get_all_tasks
- add_task
- remove_task
- update_task
- show_all_email_templates
- send_email

## Difficulty
The next steps are of medium difficulty. The methods follow similar patterns to the previously implemented methods but with different data models.
"""
dedicated_nodes = []
incomplete_nodes = [
    "get_all_tasks",
    "add_task",
    "remove_task",
    "update_task",
    "show_all_email_templates",
    "send_email"
]
```
</structured_iteration_state>

Let's complete the final iteration to implement the task-related methods and email-related methods:

<iteration_state>
```md
# Performed Steps
In this final iteration, I've implemented:
1. All task-related methods (get_all_tasks, add_task, remove_task, update_task)
2. All email-related methods (show_all_email_templates, send_email)

## Full Completions
- get_all_tasks: Implemented to retrieve all tasks assigned to the current agent
- add_task: Implemented to create a new task and add it to cache and database
- remove_task: Implemented to remove a task from cache and database
- update_task: Implemented to update a task's attributes in cache and database
- show_all_email_templates: Implemented to retrieve all email templates
- send_email: Implemented to send an email and add a contact note

## Untouched Nodes
All methods have now been implemented.

# Next Steps
The file is now fully implemented. All methods have been completed according to the requirements.

## Difficulty
The implementation is complete.
```
</iteration_state>

<next_plan>
```py
class AgentService:
    """
    Interface for all services related to an agent.
    """

    def __init__(self, schema: Schema, database: PostgresOperations):
        """
        Initialize the agent service with schema and database connection.
        """
        self.agent_id = None
        self.agent = None
        self.logged_in = False   # In every of following methods expect self.login() and self.forget_password(), raise error if not logged_in
        # this serves as a temporary cache
        self.companies: t.Dict[int, Company] = dict()     # a dictionary company_id: Company
        self.company_notes: t.Dict[int, t.List[CompanyNote]] = dict()   # a dictionary company_id: list of CompanyNote
        self.contacts: t.Dict[int, Contact] = dict()  # a dictionary contact_id: Contact
        self.contact_notes: t.Dict[int, t.List[ContactNote]] = dict()  # a dictionary contact_id: ContactNote
        self.tasks: t.Dict[int, Task] = dict()  # a dictionary task_id: Task
        self.email_templates: t.Dict[int, EmailTemplate] = dict()   # a dictionary template_id: list of EmailTemplate
        self.schema = schema
        self.database = database

    def get_all_tasks(self, order_by_due_date: bool = True):
        """
        Return all tasks assigned to the current agent.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Build SQL query
        query = f"SELECT * FROM tasks WHERE assigned_agent_id = {self.agent_id}"
        
        if order_by_due_date:
            query += " ORDER BY due_time ASC"
        
        result = self.database.execute_query(query)
        
        # Clear existing tasks cache
        self.tasks.clear()
        
        # Process results and populate tasks cache
        for task_data in result:
            task_id = task_data[0]  # Assuming task_id is the first column
            task = Task(
                task_id=task_id,
                assigned_agent_id=task_data[1],
                contact_id=task_data[2],
                company_id=task_data[3],
                name=task_data[4],
                description=task_data[5],
                create_time=task_data[6],
                due_time=task_data[7],
                status=task_data[8]
            )
            self.tasks[task_id] = task

    def add_task(self,
                 assigned_agent_id: int,
                 contact_id: int,
                 company_id: int,
                 name: str,
                 description: str,
                 create_time: str = '',
                 due_time: str = '',
                 status: str = 'incomplete',
                 task_id: int = None) -> Task:
        """
        Create a new Task object.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Set create_time if not provided
        if not create_time:
            create_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Generate task_id if not provided
        if task_id is None or task_id == -1:
            task_id = HashFunc.hash_task_id(assigned_agent_id, contact_id, company_id, name)
        
        # Create new task object
        task = Task(
            task_id=task_id,
            assigned_agent_id=assigned_agent_id,
            contact_id=contact_id,
            company_id=company_id,
            name=name,
            description=description,
            create_time=create_time,
            due_time=due_time,
            status=status
        )
        
        # Add to cache
        self.tasks[task_id] = task
        
        # Insert into database
        success = self.database.insert_record(Task.db_table_names(), task.to_record())
        
        if not success:
            raise Exception("Failed to add task to database")
        
        return task

    def remove_task(self, task_id: int) -> bool:
        """
        Remove the contact from self.tasks (if exists).
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Remove from cache if exists
        if task_id in self.tasks:
            del self.tasks[task_id]
        
        # Remove from database
        success = self.database.delete_record(Task.db_table_names(), task_id)
        
        return success

    def update_task(self, task_id: int, **kwargs) -> Task:
        """
        First get_task() and then update its corresponding attribute values based on **kwargs.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # Check if task exists in cache
        if task_id not in self.tasks:
            # If not in cache, query the database
            query = f"SELECT * FROM tasks WHERE task_id = {task_id}"
            result = self.database.execute_query(query)
            
            if not result:
                raise Exception(f"Task with id {task_id} not found")
            
            task_data = result[0]
            task = Task(
                task_id=task_data[0],
                assigned_agent_id=task_data[1],
                contact_id=task_data[2],
                company_id=task_data[3],
                name=task_data[4],
                description=task_data[5],
                create_time=task_data[6],
                due_time=task_data[7],
                status=task_data[8]
            )
            
            # Add to cache
            self.tasks[task_id] = task
        
        # Get task from cache
        task = self.tasks[task_id]
        
        # Update attributes
        task.update_attribute(**kwargs)
        
        # Update in database
        success = self.database.update_record(Task.db_table_names(), task.to_record())
        
        if not success:
            raise Exception("Failed to update task in database")
        
        return task

    def show_all_email_templates(self) -> t.List[EmailTemplate]:
        """
        Retrieve all email templates.
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        # If email templates cache is empty, query the database
        if not self.email_templates:
            query = "SELECT * FROM email_templates"
            result = self.database.execute_query(query)
            
            # Process results
            for template_data in result:
                template_id = template_data[0]  # Assuming template_id is the first column
                template = EmailTemplate(
                    email_template_id=template_id,
                    email_subject=template_data[1],
                    email_text=template_data[2]
                )
                self.email_templates[template_id] = template
        
        # Return all templates as a list
        return list(self.email_templates.values())

    def send_email(self, contact_id: int, email_subject: str, email_content: str) -> bool:
        """
        Add a new contact note using add_contact_note()
        """
        if not self.logged_in:
            raise Exception("Agent not logged in")
        
        try:
            # Get contact email
            contact = self.get_contact(contact_id)
            contact_email = contact.email
            
            # Get agent email
            agent_email = self.agent.email
            
            # In a real implementation, this would use an email service
            print(f"Sending email from {agent_email} to {contact_email}")
            print(f"Subject: {email_subject}")
            print(f"Content: {email_content}")
            
            # Add a contact note
            self.add_contact_note(
                contact_id=contact_id,
                assigned_agent_id=self.agent_id,
                new_note=f"Sending email with subject: {email_subject}

{email_content}"
            )
            
            return True
        except Exception as e:
            print(f"Failed to send email: {str(e)}")
            return False
```
</next_plan>

<structured_iteration_state>
```toml
feasible = true
file_fully_complete = true
missing_dependencies = false
irrelevant_dependencies = false
iteration_difficulty = "easy"
iteration_state = """
# Performed Steps
In this final iteration, I've implemented:
1. All task-related methods (get_all_tasks, add_task, remove_task, update_task)
2. All email-related methods (show_all_email_templates, send_email)

## Full Completions
- get_all_tasks: Implemented to retrieve all tasks assigned to the current agent
- add_task: Implemented to create a new task and add it to cache and database
- remove_task: Implemented to remove a task from cache and database
- update_task: Implemented to update a task's attributes in cache and database
- show_all_email_templates: Implemented to retrieve all email templates
- send_email: Implemented to send an email and add a contact note

## Untouched Nodes
All methods have now been implemented.

# Next Steps
The file is now fully implemented. All methods have been completed according to the requirements.

## Difficulty
The implementation is complete.
"""
dedicated_nodes = []
incomplete_nodes = []
```
</structured_iteration_state>